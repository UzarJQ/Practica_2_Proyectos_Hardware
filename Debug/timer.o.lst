   1              		.cpu arm7tdmi
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 18, 4
  11              		.file	"timer.c"
  21              	.Ltext0:
  22              		.file 1 "../timer.c"
 2163              		.align	2
 2166              	timer1_num_int:
 2167 0000 00000000 		.space	4
 2168              		.global	timer_event
 2169              		.data
 2172              	timer_event:
 2173 0000 05       		.byte	5
 2176              	evento:
 2177 0001 01       		.byte	1
 2178              		.bss
 2179              		.align	2
 2180              	led8_count:
 2181 0004 00000000 		.space	4
 2182              		.align	2
 2183              	button_id:
 2184 0008 00000000 		.space	4
 2185              		.text
 2186              		.align	2
 2187              		.global	timer_ISR
 2189              	timer_ISR:
 2190              	.LFB0:
   1:../timer.c    **** /*********************************************************************************************
   2:../timer.c    ****  * Fichero:		timer.c
   3:../timer.c    ****  * Autor:
   4:../timer.c    ****  * Descrip:		funciones de control del timer0 del s3c44b0x
   5:../timer.c    ****  * Version:
   6:../timer.c    ****  *********************************************************************************************/
   7:../timer.c    **** 
   8:../timer.c    **** /*--- ficheros de cabecera ---*/
   9:../timer.c    **** #include "timer.h"
  10:../timer.c    **** #include "44b.h"
  11:../timer.c    **** #include "44blib.h"
  12:../timer.c    **** #include "eventos.h"
  13:../timer.c    **** 
  14:../timer.c    **** /*--- variables globales ---*/
  15:../timer.c    **** extern int switch_leds;
  16:../timer.c    **** int timer1_num_int = 0; // Contador de periodos completos por el timer1
  17:../timer.c    **** Event timer_event = TIMER1_IRQ;
  18:../timer.c    **** static Event evento = PRESSED_IRQ;
  19:../timer.c    **** static int led8_count = 0;
  20:../timer.c    **** static int button_id;
  21:../timer.c    **** 
  22:../timer.c    **** /* declaraci�n de funci�n que es rutina de servicio de interrupci�n
  23:../timer.c    **** https://gcc.gnu.org/onlinedocs/gcc/ARM-Function-Attributes.html */
  24:../timer.c    **** void timer_ISR(void) __attribute__((interrupt("IRQ")));
  25:../timer.c    **** void timer1_ISR(void) __attribute__((interrupt("IRQ")));
  26:../timer.c    **** void timer2_ISR(void) __attribute__((interrupt("IRQ")));
  27:../timer.c    **** 
  28:../timer.c    **** /*--- codigo de las funciones ---*/
  29:../timer.c    **** void timer_ISR(void)
  30:../timer.c    **** {
 2191              		.loc 1 30 0
 2192              		.cfi_startproc
 2193              		@ Interrupt Service Routine.
 2194              		@ args = 0, pretend = 0, frame = 8
 2195              		@ frame_needed = 1, uses_anonymous_args = 0
 2196 0000 04C02DE5 		str	ip, [sp, #-4]!
 2197 0004 0DC0A0E1 		mov	ip, sp
 2198              	.LCFI0:
 2199              		.cfi_def_cfa_register 12
 2200 0008 1FD82DE9 		stmfd	sp!, {r0, r1, r2, r3, r4, fp, ip, lr, pc}
 2201 000c 04B04CE2 		sub	fp, ip, #4
 2202              		.cfi_offset 14, -8
 2203              		.cfi_offset 13, -12
 2204              		.cfi_offset 11, -16
 2205              		.cfi_offset 4, -20
 2206              		.cfi_offset 3, -24
 2207              		.cfi_offset 2, -28
 2208              		.cfi_offset 1, -32
 2209              		.cfi_offset 0, -36
 2210              	.LCFI1:
 2211              		.cfi_def_cfa 11, 4
 2212 0010 0CD04DE2 		sub	sp, sp, #12
  31:../timer.c    **** 	Button_state = PRESSED;
 2213              		.loc 1 31 0
 2214 0014 0030A0E3 		mov	r3, #0
 2215 0018 0120A0E3 		mov	r2, #1
 2216 001c 0020C3E5 		strb	r2, [r3, #0]
  32:../timer.c    **** 	int which_int = rEXTINTPND;
 2217              		.loc 1 32 0
 2218 0020 AC329FE5 		ldr	r3, .L15
 2219 0024 003093E5 		ldr	r3, [r3, #0]
 2220 0028 28300BE5 		str	r3, [fp, #-40]
  33:../timer.c    **** 
  34:../timer.c    **** 	if (Button_state == PRESSED)
 2221              		.loc 1 34 0
 2222 002c 0030A0E3 		mov	r3, #0
 2223 0030 0030D3E5 		ldrb	r3, [r3, #0]
 2224 0034 FF3003E2 		and	r3, r3, #255
 2225 0038 010053E3 		cmp	r3, #1
 2226 003c 5200001A 		bne	.L2
  35:../timer.c    **** 	{
  36:../timer.c    **** 		if ((timer1_leer() - last_timer_value) > 20201) // TRP
 2227              		.loc 1 36 0
 2228 0040 FEFFFFEB 		bl	timer1_leer
 2229 0044 0020A0E1 		mov	r2, r0
 2230 0048 0030A0E3 		mov	r3, #0
 2231 004c 003093E5 		ldr	r3, [r3, #0]
 2232 0050 022063E0 		rsb	r2, r3, r2
 2233 0054 7C329FE5 		ldr	r3, .L15+4
 2234 0058 030052E1 		cmp	r2, r3
 2235 005c 4A00009A 		bls	.L2
  37:../timer.c    **** 		{
  38:../timer.c    **** 
  39:../timer.c    **** 			if (!(rPDATG & 0x40) || !(rPDATG & 0x80))
 2236              		.loc 1 39 0
 2237 0060 74329FE5 		ldr	r3, .L15+8
 2238 0064 003093E5 		ldr	r3, [r3, #0]
 2239 0068 403003E2 		and	r3, r3, #64
 2240 006c 000053E3 		cmp	r3, #0
 2241 0070 0400000A 		beq	.L3
 2242              		.loc 1 39 0 is_stmt 0 discriminator 1
 2243 0074 60329FE5 		ldr	r3, .L15+8
 2244 0078 003093E5 		ldr	r3, [r3, #0]
 2245 007c 803003E2 		and	r3, r3, #128
 2246 0080 000053E3 		cmp	r3, #0
 2247 0084 0300001A 		bne	.L4
 2248              	.L3:
  40:../timer.c    **** 			{
  41:../timer.c    **** 				Button_state = MANTAINED;
 2249              		.loc 1 41 0 is_stmt 1
 2250 0088 0030A0E3 		mov	r3, #0
 2251 008c 0320A0E3 		mov	r2, #3
 2252 0090 0020C3E5 		strb	r2, [r3, #0]
 2253 0094 020000EA 		b	.L5
 2254              	.L4:
  42:../timer.c    **** 			}
  43:../timer.c    **** 			else
  44:../timer.c    **** 			{
  45:../timer.c    **** 				Button_state = RELEASED;
 2255              		.loc 1 45 0
 2256 0098 0030A0E3 		mov	r3, #0
 2257 009c 0220A0E3 		mov	r2, #2
 2258 00a0 0020C3E5 		strb	r2, [r3, #0]
 2259              	.L5:
  46:../timer.c    **** 			}
  47:../timer.c    **** 
  48:../timer.c    **** 			switch (which_int)
 2260              		.loc 1 48 0
 2261 00a4 28301BE5 		ldr	r3, [fp, #-40]
 2262 00a8 040053E3 		cmp	r3, #4
 2263 00ac 0200000A 		beq	.L7
 2264 00b0 080053E3 		cmp	r3, #8
 2265 00b4 1800000A 		beq	.L8
 2266              	.LBB2:
  49:../timer.c    **** 			{
  50:../timer.c    **** 			case 4:
  51:../timer.c    **** 				led8_count++;
  52:../timer.c    **** 				button_id = 6;
  53:../timer.c    **** 				last_timer_value = timer1_leer();
  54:../timer.c    **** 				push_debug(evento, button_id, last_timer_value);
  55:../timer.c    **** 				break;
  56:../timer.c    **** 			case 8:
  57:../timer.c    **** 				led8_count--;
  58:../timer.c    **** 				button_id = 7;
  59:../timer.c    **** 				last_timer_value = timer1_leer();
  60:../timer.c    **** 				push_debug(evento, button_id, last_timer_value);
  61:../timer.c    **** 				break;
  62:../timer.c    **** 			default:
  63:../timer.c    **** 				break;
 2267              		.loc 1 63 0
 2268 00b8 2F0000EA 		b	.L9
 2269              	.L7:
  51:../timer.c    **** 				led8_count++;
 2270              		.loc 1 51 0
 2271 00bc 1C329FE5 		ldr	r3, .L15+12
 2272 00c0 003093E5 		ldr	r3, [r3, #0]
 2273 00c4 012083E2 		add	r2, r3, #1
 2274 00c8 10329FE5 		ldr	r3, .L15+12
 2275 00cc 002083E5 		str	r2, [r3, #0]
  52:../timer.c    **** 				button_id = 6;
 2276              		.loc 1 52 0
 2277 00d0 0C329FE5 		ldr	r3, .L15+16
 2278 00d4 0620A0E3 		mov	r2, #6
 2279 00d8 002083E5 		str	r2, [r3, #0]
  53:../timer.c    **** 				last_timer_value = timer1_leer();
 2280              		.loc 1 53 0
 2281 00dc 0040A0E3 		mov	r4, #0
 2282 00e0 FEFFFFEB 		bl	timer1_leer
 2283 00e4 0030A0E1 		mov	r3, r0
 2284 00e8 003084E5 		str	r3, [r4, #0]
  54:../timer.c    **** 				push_debug(evento, button_id, last_timer_value);
 2285              		.loc 1 54 0
 2286 00ec F4319FE5 		ldr	r3, .L15+20
 2287 00f0 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2288 00f4 0310A0E1 		mov	r1, r3
 2289 00f8 E4319FE5 		ldr	r3, .L15+16
 2290 00fc 002093E5 		ldr	r2, [r3, #0]
 2291 0100 0030A0E3 		mov	r3, #0
 2292 0104 003093E5 		ldr	r3, [r3, #0]
 2293 0108 0100A0E1 		mov	r0, r1
 2294 010c 0210A0E1 		mov	r1, r2
 2295 0110 0320A0E1 		mov	r2, r3
 2296 0114 FEFFFFEB 		bl	push_debug
  55:../timer.c    **** 				break;
 2297              		.loc 1 55 0
 2298 0118 170000EA 		b	.L9
 2299              	.L8:
  57:../timer.c    **** 				led8_count--;
 2300              		.loc 1 57 0
 2301 011c BC319FE5 		ldr	r3, .L15+12
 2302 0120 003093E5 		ldr	r3, [r3, #0]
 2303 0124 012043E2 		sub	r2, r3, #1
 2304 0128 B0319FE5 		ldr	r3, .L15+12
 2305 012c 002083E5 		str	r2, [r3, #0]
  58:../timer.c    **** 				button_id = 7;
 2306              		.loc 1 58 0
 2307 0130 AC319FE5 		ldr	r3, .L15+16
 2308 0134 0720A0E3 		mov	r2, #7
 2309 0138 002083E5 		str	r2, [r3, #0]
  59:../timer.c    **** 				last_timer_value = timer1_leer();
 2310              		.loc 1 59 0
 2311 013c 0040A0E3 		mov	r4, #0
 2312 0140 FEFFFFEB 		bl	timer1_leer
 2313 0144 0030A0E1 		mov	r3, r0
 2314 0148 003084E5 		str	r3, [r4, #0]
  60:../timer.c    **** 				push_debug(evento, button_id, last_timer_value);
 2315              		.loc 1 60 0
 2316 014c 94319FE5 		ldr	r3, .L15+20
 2317 0150 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2318 0154 0310A0E1 		mov	r1, r3
 2319 0158 84319FE5 		ldr	r3, .L15+16
 2320 015c 002093E5 		ldr	r2, [r3, #0]
 2321 0160 0030A0E3 		mov	r3, #0
 2322 0164 003093E5 		ldr	r3, [r3, #0]
 2323 0168 0100A0E1 		mov	r0, r1
 2324 016c 0210A0E1 		mov	r1, r2
 2325 0170 0320A0E1 		mov	r2, r3
 2326 0174 FEFFFFEB 		bl	push_debug
  61:../timer.c    **** 				break;
 2327              		.loc 1 61 0
 2328 0178 0000A0E1 		mov	r0, r0	@ nop
 2329              	.L9:
 2330              	.LBE2:
  64:../timer.c    **** 			}
  65:../timer.c    **** 			last_timer_value = timer1_leer();
 2331              		.loc 1 65 0
 2332 017c 0040A0E3 		mov	r4, #0
 2333 0180 FEFFFFEB 		bl	timer1_leer
 2334 0184 0030A0E1 		mov	r3, r0
 2335 0188 003084E5 		str	r3, [r4, #0]
 2336              	.L2:
  66:../timer.c    **** 		}
  67:../timer.c    **** 	}
  68:../timer.c    **** 
  69:../timer.c    **** 	if (Button_state == MANTAINED)
 2337              		.loc 1 69 0
 2338 018c 0030A0E3 		mov	r3, #0
 2339 0190 0030D3E5 		ldrb	r3, [r3, #0]
 2340 0194 FF3003E2 		and	r3, r3, #255
 2341 0198 030053E3 		cmp	r3, #3
 2342 019c 2000001A 		bne	.L10
  70:../timer.c    **** 	{
  71:../timer.c    **** 
  72:../timer.c    **** 		if ((timer1_leer() - last_timer_value) > 50000) // Monitorizar cada 50 ms
 2343              		.loc 1 72 0
 2344 01a0 FEFFFFEB 		bl	timer1_leer
 2345 01a4 0020A0E1 		mov	r2, r0
 2346 01a8 0030A0E3 		mov	r3, #0
 2347 01ac 003093E5 		ldr	r3, [r3, #0]
 2348 01b0 022063E0 		rsb	r2, r3, r2
 2349 01b4 30319FE5 		ldr	r3, .L15+24
 2350 01b8 030052E1 		cmp	r2, r3
 2351 01bc 1000009A 		bls	.L11
  73:../timer.c    **** 		{
  74:../timer.c    **** 			if ((rPDATG & 0x40) || (rPDATG & 0x80))
 2352              		.loc 1 74 0
 2353 01c0 14319FE5 		ldr	r3, .L15+8
 2354 01c4 003093E5 		ldr	r3, [r3, #0]
 2355 01c8 403003E2 		and	r3, r3, #64
 2356 01cc 000053E3 		cmp	r3, #0
 2357 01d0 0400001A 		bne	.L12
 2358              		.loc 1 74 0 is_stmt 0 discriminator 1
 2359 01d4 00319FE5 		ldr	r3, .L15+8
 2360 01d8 003093E5 		ldr	r3, [r3, #0]
 2361 01dc 803003E2 		and	r3, r3, #128
 2362 01e0 000053E3 		cmp	r3, #0
 2363 01e4 0300000A 		beq	.L13
 2364              	.L12:
  75:../timer.c    **** 			{
  76:../timer.c    **** 				Button_state = RELEASED;
 2365              		.loc 1 76 0 is_stmt 1
 2366 01e8 0030A0E3 		mov	r3, #0
 2367 01ec 0220A0E3 		mov	r2, #2
 2368 01f0 0020C3E5 		strb	r2, [r3, #0]
 2369 01f4 020000EA 		b	.L11
 2370              	.L13:
  77:../timer.c    **** 			}
  78:../timer.c    **** 			else
  79:../timer.c    **** 			{
  80:../timer.c    **** 				Button_state = MANTAINED;
 2371              		.loc 1 80 0
 2372 01f8 0030A0E3 		mov	r3, #0
 2373 01fc 0320A0E3 		mov	r2, #3
 2374 0200 0020C3E5 		strb	r2, [r3, #0]
 2375              	.L11:
  81:../timer.c    **** 			}
  82:../timer.c    **** 		}
  83:../timer.c    **** 		last_timer_value = timer1_leer();
 2376              		.loc 1 83 0
 2377 0204 0040A0E3 		mov	r4, #0
 2378 0208 FEFFFFEB 		bl	timer1_leer
 2379 020c 0030A0E1 		mov	r3, r0
 2380 0210 003084E5 		str	r3, [r4, #0]
  84:../timer.c    **** 
  85:../timer.c    **** 		last_timer_value = timer1_leer();
 2381              		.loc 1 85 0
 2382 0214 0040A0E3 		mov	r4, #0
 2383 0218 FEFFFFEB 		bl	timer1_leer
 2384 021c 0030A0E1 		mov	r3, r0
 2385 0220 003084E5 		str	r3, [r4, #0]
 2386              	.L10:
  86:../timer.c    **** 	}
  87:../timer.c    **** 
  88:../timer.c    **** 	if (Button_state == RELEASED)
 2387              		.loc 1 88 0
 2388 0224 0030A0E3 		mov	r3, #0
 2389 0228 0030D3E5 		ldrb	r3, [r3, #0]
 2390 022c FF3003E2 		and	r3, r3, #255
 2391 0230 020053E3 		cmp	r3, #2
 2392 0234 1800001A 		bne	.L14
  89:../timer.c    **** 	{
  90:../timer.c    **** 
  91:../timer.c    **** 		if ((timer1_leer() - last_timer_value) > 20201) // TRD
 2393              		.loc 1 91 0
 2394 0238 FEFFFFEB 		bl	timer1_leer
 2395 023c 0020A0E1 		mov	r2, r0
 2396 0240 0030A0E3 		mov	r3, #0
 2397 0244 003093E5 		ldr	r3, [r3, #0]
 2398 0248 022063E0 		rsb	r2, r3, r2
 2399 024c 84309FE5 		ldr	r3, .L15+4
 2400 0250 030052E1 		cmp	r2, r3
 2401 0254 1000009A 		bls	.L14
 2402              	.LBB3:
  92:../timer.c    **** 		{
  93:../timer.c    **** 			evento = RELEASED_IRQ;
 2403              		.loc 1 93 0
 2404 0258 88309FE5 		ldr	r3, .L15+20
 2405 025c 0320A0E3 		mov	r2, #3
 2406 0260 0020C3E5 		strb	r2, [r3, #0]
  94:../timer.c    **** 			push_debug(evento, button_id, last_timer_value);
 2407              		.loc 1 94 0
 2408 0264 7C309FE5 		ldr	r3, .L15+20
 2409 0268 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2410 026c 0310A0E1 		mov	r1, r3
 2411 0270 6C309FE5 		ldr	r3, .L15+16
 2412 0274 002093E5 		ldr	r2, [r3, #0]
 2413 0278 0030A0E3 		mov	r3, #0
 2414 027c 003093E5 		ldr	r3, [r3, #0]
 2415 0280 0100A0E1 		mov	r0, r1
 2416 0284 0210A0E1 		mov	r1, r2
 2417 0288 0320A0E1 		mov	r2, r3
 2418 028c FEFFFFEB 		bl	push_debug
  95:../timer.c    **** 			Button_state = WAITING;
 2419              		.loc 1 95 0
 2420 0290 0030A0E3 		mov	r3, #0
 2421 0294 0020A0E3 		mov	r2, #0
 2422 0298 0020C3E5 		strb	r2, [r3, #0]
 2423              	.L14:
 2424              	.LBE3:
  96:../timer.c    **** 		}
  97:../timer.c    **** 	}
  98:../timer.c    **** 
  99:../timer.c    **** 	D8Led_symbol(led8_count & 0xf);
 2425              		.loc 1 99 0
 2426 029c 3C309FE5 		ldr	r3, .L15+12
 2427 02a0 003093E5 		ldr	r3, [r3, #0]
 2428 02a4 0F3003E2 		and	r3, r3, #15
 2429 02a8 0300A0E1 		mov	r0, r3
 2430 02ac FEFFFFEB 		bl	D8Led_symbol
 100:../timer.c    **** 
 101:../timer.c    **** 	/* borrar bit en I_ISPC para desactivar la solicitud de interrupci�n*/
 102:../timer.c    **** 	rI_ISPC |= BIT_TIMER0; // BIT_TIMER0 est� definido en 44b.h y pone un uno en el bit 13 que corre
 2431              		.loc 1 102 0
 2432 02b0 38309FE5 		ldr	r3, .L15+28
 2433 02b4 34209FE5 		ldr	r2, .L15+28
 2434 02b8 002092E5 		ldr	r2, [r2, #0]
 2435 02bc 022A82E3 		orr	r2, r2, #8192
 2436 02c0 002083E5 		str	r2, [r3, #0]
 103:../timer.c    **** }
 2437              		.loc 1 103 0
 2438 02c4 20D04BE2 		sub	sp, fp, #32
 2439 02c8 1F689DE8 		ldmfd	sp, {r0, r1, r2, r3, r4, fp, sp, lr}
 2440 02cc 04C09DE4 		ldmfd	sp!, {ip}
 2441 02d0 04F05EE2 		subs	pc, lr, #4
 2442              	.L16:
 2443              		.align	2
 2444              	.L15:
 2445 02d4 5400D201 		.word	30539860
 2446 02d8 E94E0000 		.word	20201
 2447 02dc 4400D201 		.word	30539844
 2448 02e0 04000000 		.word	led8_count
 2449 02e4 08000000 		.word	button_id
 2450 02e8 01000000 		.word	evento
 2451 02ec 50C30000 		.word	50000
 2452 02f0 2400E001 		.word	31457316
 2453              		.cfi_endproc
 2454              	.LFE0:
 2456              		.align	2
 2457              		.global	timer_init
 2459              	timer_init:
 2460              	.LFB1:
 104:../timer.c    **** 
 105:../timer.c    **** void timer_init(void)
 106:../timer.c    **** {
 2461              		.loc 1 106 0
 2462              		.cfi_startproc
 2463              		@ Function supports interworking.
 2464              		@ args = 0, pretend = 0, frame = 0
 2465              		@ frame_needed = 1, uses_anonymous_args = 0
 2466 02f4 0DC0A0E1 		mov	ip, sp
 2467              	.LCFI2:
 2468              		.cfi_def_cfa_register 12
 2469 02f8 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2470 02fc 04B04CE2 		sub	fp, ip, #4
 2471              		.cfi_offset 14, -8
 2472              		.cfi_offset 13, -12
 2473              		.cfi_offset 11, -16
 2474              	.LCFI3:
 2475              		.cfi_def_cfa 11, 4
 107:../timer.c    **** 	/* Configuracion controlador de interrupciones */
 108:../timer.c    **** 	rINTMOD = 0x0;						// Configura las lineas como de tipo IRQ
 2476              		.loc 1 108 0
 2477 0300 84309FE5 		ldr	r3, .L18
 2478 0304 0020A0E3 		mov	r2, #0
 2479 0308 002083E5 		str	r2, [r3, #0]
 109:../timer.c    **** 	rINTCON = 0x1;						// Habilita int. vectorizadas y la linea IRQ (FIQ no)
 2480              		.loc 1 109 0
 2481 030c 1E36A0E3 		mov	r3, #31457280
 2482 0310 0120A0E3 		mov	r2, #1
 2483 0314 002083E5 		str	r2, [r3, #0]
 110:../timer.c    **** 	rINTMSK &= ~(BIT_TIMER0); // habilitamos en vector de mascaras de interrupcion el Timer0 (bits 26 
 2484              		.loc 1 110 0
 2485 0318 70309FE5 		ldr	r3, .L18+4
 2486 031c 6C209FE5 		ldr	r2, .L18+4
 2487 0320 002092E5 		ldr	r2, [r2, #0]
 2488 0324 022AC2E3 		bic	r2, r2, #8192
 2489 0328 002083E5 		str	r2, [r3, #0]
 111:../timer.c    **** 
 112:../timer.c    **** 	/* Establece la rutina de servicio para TIMER0 */
 113:../timer.c    **** 	pISR_TIMER0 = (unsigned)timer_ISR;
 2490              		.loc 1 113 0
 2491 032c 60309FE5 		ldr	r3, .L18+8
 2492 0330 60209FE5 		ldr	r2, .L18+12
 2493 0334 002083E5 		str	r2, [r3, #0]
 114:../timer.c    **** 
 115:../timer.c    **** 	/* Configura el Timer0 */
 116:../timer.c    **** 	rTCFG0 = 100;		 // ajusta el preescalado
 2494              		.loc 1 116 0
 2495 0338 5C309FE5 		ldr	r3, .L18+16
 2496 033c 6420A0E3 		mov	r2, #100
 2497 0340 002083E5 		str	r2, [r3, #0]
 117:../timer.c    **** 	rTCFG1 = 0x0;		 // selecciona la entrada del mux que proporciona el reloj. La 00 corresponde a un 
 2498              		.loc 1 117 0
 2499 0344 54309FE5 		ldr	r3, .L18+20
 2500 0348 0020A0E3 		mov	r2, #0
 2501 034c 002083E5 		str	r2, [r3, #0]
 118:../timer.c    **** 	rTCNTB0 = 50000; // valor inicial de cuenta (la cuenta es descendente)
 2502              		.loc 1 118 0
 2503 0350 4C309FE5 		ldr	r3, .L18+24
 2504 0354 4C209FE5 		ldr	r2, .L18+28
 2505 0358 002083E5 		str	r2, [r3, #0]
 119:../timer.c    **** 	rTCMPB0 = 0;		 // valor de comparaci�n
 2506              		.loc 1 119 0
 2507 035c 48309FE5 		ldr	r3, .L18+32
 2508 0360 0020A0E3 		mov	r2, #0
 2509 0364 002083E5 		str	r2, [r3, #0]
 120:../timer.c    **** 	/* establecer update=manual (bit 1) + inverter=on (�? ser� inverter off un cero en el bit 2 po
 121:../timer.c    **** 	rTCON = 0x2;
 2510              		.loc 1 121 0
 2511 0368 40309FE5 		ldr	r3, .L18+36
 2512 036c 0220A0E3 		mov	r2, #2
 2513 0370 002083E5 		str	r2, [r3, #0]
 122:../timer.c    **** 	/* iniciar timer (bit 0) con auto-reload (bit 3)*/
 123:../timer.c    **** 	rTCON = 0x09;
 2514              		.loc 1 123 0
 2515 0374 34309FE5 		ldr	r3, .L18+36
 2516 0378 0920A0E3 		mov	r2, #9
 2517 037c 002083E5 		str	r2, [r3, #0]
 124:../timer.c    **** }
 2518              		.loc 1 124 0
 2519 0380 0CD04BE2 		sub	sp, fp, #12
 2520 0384 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2521 0388 1EFF2FE1 		bx	lr
 2522              	.L19:
 2523              		.align	2
 2524              	.L18:
 2525 038c 0800E001 		.word	31457288
 2526 0390 0C00E001 		.word	31457292
 2527 0394 54FF7F0C 		.word	209715028
 2528 0398 00000000 		.word	timer_ISR
 2529 039c 0000D501 		.word	30736384
 2530 03a0 0400D501 		.word	30736388
 2531 03a4 0C00D501 		.word	30736396
 2532 03a8 50C30000 		.word	50000
 2533 03ac 1000D501 		.word	30736400
 2534 03b0 0800D501 		.word	30736392
 2535              		.cfi_endproc
 2536              	.LFE1:
 2538              		.align	2
 2539              		.global	timer1_inicializar
 2541              	timer1_inicializar:
 2542              	.LFB2:
 125:../timer.c    **** 
 126:../timer.c    **** void timer1_inicializar(void)
 127:../timer.c    **** {
 2543              		.loc 1 127 0
 2544              		.cfi_startproc
 2545              		@ Function supports interworking.
 2546              		@ args = 0, pretend = 0, frame = 0
 2547              		@ frame_needed = 1, uses_anonymous_args = 0
 2548 03b4 0DC0A0E1 		mov	ip, sp
 2549              	.LCFI4:
 2550              		.cfi_def_cfa_register 12
 2551 03b8 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2552 03bc 04B04CE2 		sub	fp, ip, #4
 2553              		.cfi_offset 14, -8
 2554              		.cfi_offset 13, -12
 2555              		.cfi_offset 11, -16
 2556              	.LCFI5:
 2557              		.cfi_def_cfa 11, 4
 128:../timer.c    **** 	rINTMOD = 0x0; // Configura las lineas como de tipo IRQ
 2558              		.loc 1 128 0
 2559 03c0 AC309FE5 		ldr	r3, .L21
 2560 03c4 0020A0E3 		mov	r2, #0
 2561 03c8 002083E5 		str	r2, [r3, #0]
 129:../timer.c    **** 	rINTCON = 0x1; // Habilita int. vectorizadas y la linea IRQ (FIQ no)
 2562              		.loc 1 129 0
 2563 03cc 1E36A0E3 		mov	r3, #31457280
 2564 03d0 0120A0E3 		mov	r2, #1
 2565 03d4 002083E5 		str	r2, [r3, #0]
 130:../timer.c    **** 	rINTMSK &= ~(BIT_TIMER1);
 2566              		.loc 1 130 0
 2567 03d8 98309FE5 		ldr	r3, .L21+4
 2568 03dc 94209FE5 		ldr	r2, .L21+4
 2569 03e0 002092E5 		ldr	r2, [r2, #0]
 2570 03e4 012AC2E3 		bic	r2, r2, #4096
 2571 03e8 002083E5 		str	r2, [r3, #0]
 131:../timer.c    **** 
 132:../timer.c    **** 	pISR_TIMER1 = (unsigned)timer1_ISR;
 2572              		.loc 1 132 0
 2573 03ec 88309FE5 		ldr	r3, .L21+8
 2574 03f0 88209FE5 		ldr	r2, .L21+12
 2575 03f4 002083E5 		str	r2, [r3, #0]
 133:../timer.c    **** 
 134:../timer.c    **** 	// Configuracion del Timer1
 135:../timer.c    **** 	rTCFG0 = 255;
 2576              		.loc 1 135 0
 2577 03f8 84309FE5 		ldr	r3, .L21+16
 2578 03fc FF20A0E3 		mov	r2, #255
 2579 0400 002083E5 		str	r2, [r3, #0]
 136:../timer.c    **** 	rTCFG1 = 0x0;
 2580              		.loc 1 136 0
 2581 0404 7C309FE5 		ldr	r3, .L21+20
 2582 0408 0020A0E3 		mov	r2, #0
 2583 040c 002083E5 		str	r2, [r3, #0]
 137:../timer.c    **** 
 138:../timer.c    **** 	rTCNTB1 = 64000;
 2584              		.loc 1 138 0
 2585 0410 74309FE5 		ldr	r3, .L21+24
 2586 0414 FA2CA0E3 		mov	r2, #64000
 2587 0418 002083E5 		str	r2, [r3, #0]
 139:../timer.c    **** 	rTCMPB1 = 0x0;
 2588              		.loc 1 139 0
 2589 041c 6C309FE5 		ldr	r3, .L21+28
 2590 0420 0020A0E3 		mov	r2, #0
 2591 0424 002083E5 		str	r2, [r3, #0]
 140:../timer.c    **** 
 141:../timer.c    **** 	rTCON |= (1 << 9);																				// Set bit 9 (update=manual)
 2592              		.loc 1 141 0
 2593 0428 64309FE5 		ldr	r3, .L21+32
 2594 042c 60209FE5 		ldr	r2, .L21+32
 2595 0430 002092E5 		ldr	r2, [r2, #0]
 2596 0434 022C82E3 		orr	r2, r2, #512
 2597 0438 002083E5 		str	r2, [r3, #0]
 142:../timer.c    **** 	rTCON &= ~(1 << 11);																			// Clear bit 11 (auto-reload off)
 2598              		.loc 1 142 0
 2599 043c 50309FE5 		ldr	r3, .L21+32
 2600 0440 4C209FE5 		ldr	r2, .L21+32
 2601 0444 002092E5 		ldr	r2, [r2, #0]
 2602 0448 022BC2E3 		bic	r2, r2, #2048
 2603 044c 002083E5 		str	r2, [r3, #0]
 143:../timer.c    **** 	rTCON = (rTCON & ~(0x1 << 9)) | (0x1 << 11) | (0x1 << 8); // Clear bit 9 and set bit 11 (update=ma
 2604              		.loc 1 143 0
 2605 0450 3C309FE5 		ldr	r3, .L21+32
 2606 0454 38209FE5 		ldr	r2, .L21+32
 2607 0458 002092E5 		ldr	r2, [r2, #0]
 2608 045c 0B2CC2E3 		bic	r2, r2, #2816
 2609 0460 092C82E3 		orr	r2, r2, #2304
 2610 0464 002083E5 		str	r2, [r3, #0]
 144:../timer.c    **** }
 2611              		.loc 1 144 0
 2612 0468 0CD04BE2 		sub	sp, fp, #12
 2613 046c 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2614 0470 1EFF2FE1 		bx	lr
 2615              	.L22:
 2616              		.align	2
 2617              	.L21:
 2618 0474 0800E001 		.word	31457288
 2619 0478 0C00E001 		.word	31457292
 2620 047c 50FF7F0C 		.word	209715024
 2621 0480 00000000 		.word	timer1_ISR
 2622 0484 0000D501 		.word	30736384
 2623 0488 0400D501 		.word	30736388
 2624 048c 1800D501 		.word	30736408
 2625 0490 1C00D501 		.word	30736412
 2626 0494 0800D501 		.word	30736392
 2627              		.cfi_endproc
 2628              	.LFE2:
 2630              		.align	2
 2631              		.global	timer1_ISR
 2633              	timer1_ISR:
 2634              	.LFB3:
 145:../timer.c    **** 
 146:../timer.c    **** void timer1_ISR(void)
 147:../timer.c    **** {
 2635              		.loc 1 147 0
 2636              		.cfi_startproc
 2637              		@ Interrupt Service Routine.
 2638              		@ args = 0, pretend = 0, frame = 0
 2639              		@ frame_needed = 1, uses_anonymous_args = 0
 2640 0498 04C02DE5 		str	ip, [sp, #-4]!
 2641 049c 0DC0A0E1 		mov	ip, sp
 2642              	.LCFI6:
 2643              		.cfi_def_cfa_register 12
 2644 04a0 0CD82DE9 		stmfd	sp!, {r2, r3, fp, ip, lr, pc}
 2645 04a4 04B04CE2 		sub	fp, ip, #4
 2646              		.cfi_offset 14, -8
 2647              		.cfi_offset 13, -12
 2648              		.cfi_offset 11, -16
 2649              		.cfi_offset 3, -20
 2650              		.cfi_offset 2, -24
 2651              	.LCFI7:
 2652              		.cfi_def_cfa 11, 4
 148:../timer.c    **** 	timer1_num_int++; // Aumentar el contador de ciclos completos
 2653              		.loc 1 148 0
 2654 04a8 30309FE5 		ldr	r3, .L24
 2655 04ac 003093E5 		ldr	r3, [r3, #0]
 2656 04b0 012083E2 		add	r2, r3, #1
 2657 04b4 24309FE5 		ldr	r3, .L24
 2658 04b8 002083E5 		str	r2, [r3, #0]
 149:../timer.c    **** 
 150:../timer.c    **** 	rI_ISPC |= BIT_TIMER1; // Desactivar la solicitud de interrupcion del timer1
 2659              		.loc 1 150 0
 2660 04bc 20309FE5 		ldr	r3, .L24+4
 2661 04c0 1C209FE5 		ldr	r2, .L24+4
 2662 04c4 002092E5 		ldr	r2, [r2, #0]
 2663 04c8 012A82E3 		orr	r2, r2, #4096
 2664 04cc 002083E5 		str	r2, [r3, #0]
 151:../timer.c    **** 
 152:../timer.c    **** 	//	gestionar_boton();
 153:../timer.c    **** }
 2665              		.loc 1 153 0
 2666 04d0 14D04BE2 		sub	sp, fp, #20
 2667 04d4 0C689DE8 		ldmfd	sp, {r2, r3, fp, sp, lr}
 2668 04d8 04C09DE4 		ldmfd	sp!, {ip}
 2669 04dc 04F05EE2 		subs	pc, lr, #4
 2670              	.L25:
 2671              		.align	2
 2672              	.L24:
 2673 04e0 00000000 		.word	timer1_num_int
 2674 04e4 2400E001 		.word	31457316
 2675              		.cfi_endproc
 2676              	.LFE3:
 2678              		.align	2
 2679              		.global	timer1_empezar
 2681              	timer1_empezar:
 2682              	.LFB4:
 154:../timer.c    **** 
 155:../timer.c    **** void timer1_empezar()
 156:../timer.c    **** {
 2683              		.loc 1 156 0
 2684              		.cfi_startproc
 2685              		@ Function supports interworking.
 2686              		@ args = 0, pretend = 0, frame = 0
 2687              		@ frame_needed = 1, uses_anonymous_args = 0
 2688 04e8 0DC0A0E1 		mov	ip, sp
 2689              	.LCFI8:
 2690              		.cfi_def_cfa_register 12
 2691 04ec 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2692 04f0 04B04CE2 		sub	fp, ip, #4
 2693              		.cfi_offset 14, -8
 2694              		.cfi_offset 13, -12
 2695              		.cfi_offset 11, -16
 2696              	.LCFI9:
 2697              		.cfi_def_cfa 11, 4
 157:../timer.c    **** 	// Reiniciar el contador de interrupciones
 158:../timer.c    **** 	timer1_num_int = 0;
 2698              		.loc 1 158 0
 2699 04f4 58309FE5 		ldr	r3, .L27
 2700 04f8 0020A0E3 		mov	r2, #0
 2701 04fc 002083E5 		str	r2, [r3, #0]
 159:../timer.c    **** 
 160:../timer.c    **** 	// Reiniciar el valor del contador del timer1
 161:../timer.c    **** 	rTCNTB1 = 64000;
 2702              		.loc 1 161 0
 2703 0500 50309FE5 		ldr	r3, .L27+4
 2704 0504 FA2CA0E3 		mov	r2, #64000
 2705 0508 002083E5 		str	r2, [r3, #0]
 162:../timer.c    **** 
 163:../timer.c    **** 	// Establecer update=manual (bit 9) para reiniciar el contador
 164:../timer.c    **** 	rTCON |= (0x1 << 9);
 2706              		.loc 1 164 0
 2707 050c 48309FE5 		ldr	r3, .L27+8
 2708 0510 44209FE5 		ldr	r2, .L27+8
 2709 0514 002092E5 		ldr	r2, [r2, #0]
 2710 0518 022C82E3 		orr	r2, r2, #512
 2711 051c 002083E5 		str	r2, [r3, #0]
 165:../timer.c    **** 
 166:../timer.c    **** 	// Iniciar el timer1 (bit 8)
 167:../timer.c    **** 	rTCON |= (0x1 << 8);
 2712              		.loc 1 167 0
 2713 0520 34309FE5 		ldr	r3, .L27+8
 2714 0524 30209FE5 		ldr	r2, .L27+8
 2715 0528 002092E5 		ldr	r2, [r2, #0]
 2716 052c 012C82E3 		orr	r2, r2, #256
 2717 0530 002083E5 		str	r2, [r3, #0]
 168:../timer.c    **** 
 169:../timer.c    **** 	// Desactivar el bit de update manual para permitir el funcionamiento normal
 170:../timer.c    **** 	rTCON &= ~0x100;
 2718              		.loc 1 170 0
 2719 0534 20309FE5 		ldr	r3, .L27+8
 2720 0538 1C209FE5 		ldr	r2, .L27+8
 2721 053c 002092E5 		ldr	r2, [r2, #0]
 2722 0540 012CC2E3 		bic	r2, r2, #256
 2723 0544 002083E5 		str	r2, [r3, #0]
 171:../timer.c    **** }
 2724              		.loc 1 171 0
 2725 0548 0CD04BE2 		sub	sp, fp, #12
 2726 054c 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2727 0550 1EFF2FE1 		bx	lr
 2728              	.L28:
 2729              		.align	2
 2730              	.L27:
 2731 0554 00000000 		.word	timer1_num_int
 2732 0558 1800D501 		.word	30736408
 2733 055c 0800D501 		.word	30736392
 2734              		.cfi_endproc
 2735              	.LFE4:
 2737              		.align	2
 2738              		.global	timer1_leer
 2740              	timer1_leer:
 2741              	.LFB5:
 172:../timer.c    **** 
 173:../timer.c    **** unsigned int timer1_leer()
 174:../timer.c    **** {
 2742              		.loc 1 174 0
 2743              		.cfi_startproc
 2744              		@ Function supports interworking.
 2745              		@ args = 0, pretend = 0, frame = 8
 2746              		@ frame_needed = 1, uses_anonymous_args = 0
 2747 0560 0DC0A0E1 		mov	ip, sp
 2748              	.LCFI10:
 2749              		.cfi_def_cfa_register 12
 2750 0564 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2751 0568 04B04CE2 		sub	fp, ip, #4
 2752              		.cfi_offset 14, -8
 2753              		.cfi_offset 13, -12
 2754              		.cfi_offset 11, -16
 2755              	.LCFI11:
 2756              		.cfi_def_cfa 11, 4
 2757 056c 08D04DE2 		sub	sp, sp, #8
 175:../timer.c    **** 
 176:../timer.c    **** 	unsigned int valor_cuenta = rTCNTO1; // Leer el valor actual del contador
 2758              		.loc 1 176 0
 2759 0570 3C309FE5 		ldr	r3, .L30
 2760 0574 003093E5 		ldr	r3, [r3, #0]
 2761 0578 10300BE5 		str	r3, [fp, #-16]
 177:../timer.c    **** 	// Calcular el tiempo transcurrido en el timer1
 178:../timer.c    **** 	// timer1_num_int * 64000 es el total de ticks de los ciclos completos
 179:../timer.c    **** 	// (2.0 / 33.0) es el factor de conversion de ticks a microsegundos
 180:../timer.c    **** 	unsigned int tiempo_transcurrido = (timer1_num_int * 65536) + (65535 - valor_cuenta);
 2762              		.loc 1 180 0
 2763 057c 34309FE5 		ldr	r3, .L30+4
 2764 0580 003093E5 		ldr	r3, [r3, #0]
 2765 0584 0338A0E1 		mov	r3, r3, asl #16
 2766 0588 0320A0E1 		mov	r2, r3
 2767 058c 10301BE5 		ldr	r3, [fp, #-16]
 2768 0590 023063E0 		rsb	r3, r3, r2
 2769 0594 FF3C83E2 		add	r3, r3, #65280
 2770 0598 FF3083E2 		add	r3, r3, #255
 2771 059c 14300BE5 		str	r3, [fp, #-20]
 181:../timer.c    **** 
 182:../timer.c    **** 	return tiempo_transcurrido;
 2772              		.loc 1 182 0
 2773 05a0 14301BE5 		ldr	r3, [fp, #-20]
 183:../timer.c    **** }
 2774              		.loc 1 183 0
 2775 05a4 0300A0E1 		mov	r0, r3
 2776 05a8 0CD04BE2 		sub	sp, fp, #12
 2777 05ac 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2778 05b0 1EFF2FE1 		bx	lr
 2779              	.L31:
 2780              		.align	2
 2781              	.L30:
 2782 05b4 2000D501 		.word	30736416
 2783 05b8 00000000 		.word	timer1_num_int
 2784              		.cfi_endproc
 2785              	.LFE5:
 2787              		.align	2
 2788              		.global	timer1_parar
 2790              	timer1_parar:
 2791              	.LFB6:
 184:../timer.c    **** 
 185:../timer.c    **** unsigned int timer1_parar()
 186:../timer.c    **** {
 2792              		.loc 1 186 0
 2793              		.cfi_startproc
 2794              		@ Function supports interworking.
 2795              		@ args = 0, pretend = 0, frame = 0
 2796              		@ frame_needed = 1, uses_anonymous_args = 0
 2797 05bc 0DC0A0E1 		mov	ip, sp
 2798              	.LCFI12:
 2799              		.cfi_def_cfa_register 12
 2800 05c0 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2801 05c4 04B04CE2 		sub	fp, ip, #4
 2802              		.cfi_offset 14, -8
 2803              		.cfi_offset 13, -12
 2804              		.cfi_offset 11, -16
 2805              	.LCFI13:
 2806              		.cfi_def_cfa 11, 4
 187:../timer.c    **** 	rTCON &= ~(0x1 << 8); // Desactivar el timer 1 (bit 9 y 11)
 2807              		.loc 1 187 0
 2808 05c8 24309FE5 		ldr	r3, .L33
 2809 05cc 20209FE5 		ldr	r2, .L33
 2810 05d0 002092E5 		ldr	r2, [r2, #0]
 2811 05d4 012CC2E3 		bic	r2, r2, #256
 2812 05d8 002083E5 		str	r2, [r3, #0]
 188:../timer.c    **** 
 189:../timer.c    **** 	return timer1_leer();
 2813              		.loc 1 189 0
 2814 05dc FEFFFFEB 		bl	timer1_leer
 2815 05e0 0030A0E1 		mov	r3, r0
 190:../timer.c    **** }
 2816              		.loc 1 190 0
 2817 05e4 0300A0E1 		mov	r0, r3
 2818 05e8 0CD04BE2 		sub	sp, fp, #12
 2819 05ec 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2820 05f0 1EFF2FE1 		bx	lr
 2821              	.L34:
 2822              		.align	2
 2823              	.L33:
 2824 05f4 0800D501 		.word	30736392
 2825              		.cfi_endproc
 2826              	.LFE6:
 2828              		.align	2
 2829              		.global	timer2_ISR
 2831              	timer2_ISR:
 2832              	.LFB7:
 191:../timer.c    **** 
 192:../timer.c    **** void timer2_ISR(void)
 193:../timer.c    **** {
 2833              		.loc 1 193 0
 2834              		.cfi_startproc
 2835              		@ Interrupt Service Routine.
 2836              		@ args = 0, pretend = 0, frame = 0
 2837              		@ frame_needed = 1, uses_anonymous_args = 0
 2838 05f8 04C02DE5 		str	ip, [sp, #-4]!
 2839 05fc 0DC0A0E1 		mov	ip, sp
 2840              	.LCFI14:
 2841              		.cfi_def_cfa_register 12
 2842 0600 0FD82DE9 		stmfd	sp!, {r0, r1, r2, r3, fp, ip, lr, pc}
 2843 0604 04B04CE2 		sub	fp, ip, #4
 2844              		.cfi_offset 14, -8
 2845              		.cfi_offset 13, -12
 2846              		.cfi_offset 11, -16
 2847              		.cfi_offset 3, -20
 2848              		.cfi_offset 2, -24
 2849              		.cfi_offset 1, -28
 2850              		.cfi_offset 0, -32
 2851              	.LCFI15:
 2852              		.cfi_def_cfa 11, 4
 194:../timer.c    **** 	static int led_status = 0; // Estado del LED: 0 = apagado, 1 = encendido
 195:../timer.c    **** 
 196:../timer.c    **** 	if (led_status == 0)
 2853              		.loc 1 196 0
 2854 0608 50309FE5 		ldr	r3, .L38
 2855 060c 003093E5 		ldr	r3, [r3, #0]
 2856 0610 000053E3 		cmp	r3, #0
 2857 0614 0400001A 		bne	.L36
 2858              	.LBB4:
 197:../timer.c    **** 	{
 198:../timer.c    **** 		led2_on(); // Enciende el LED derecho
 2859              		.loc 1 198 0
 2860 0618 FEFFFFEB 		bl	led2_on
 199:../timer.c    **** 		led_status = 1;
 2861              		.loc 1 199 0
 2862 061c 3C309FE5 		ldr	r3, .L38
 2863 0620 0120A0E3 		mov	r2, #1
 2864 0624 002083E5 		str	r2, [r3, #0]
 2865 0628 030000EA 		b	.L37
 2866              	.L36:
 2867              	.LBE4:
 2868              	.LBB5:
 200:../timer.c    **** 	}
 201:../timer.c    **** 	else
 202:../timer.c    **** 	{
 203:../timer.c    **** 		led2_off(); // Apaga el LED derecho
 2869              		.loc 1 203 0
 2870 062c FEFFFFEB 		bl	led2_off
 204:../timer.c    **** 		led_status = 0;
 2871              		.loc 1 204 0
 2872 0630 28309FE5 		ldr	r3, .L38
 2873 0634 0020A0E3 		mov	r2, #0
 2874 0638 002083E5 		str	r2, [r3, #0]
 2875              	.L37:
 2876              	.LBE5:
 205:../timer.c    **** 	}
 206:../timer.c    **** 
 207:../timer.c    **** 	// Borrar la solicitud de interrupción
 208:../timer.c    **** 	rI_ISPC |= BIT_TIMER2; // BIT_TIMER2 está definido y pone un 1 en el bit correspondiente para des
 2877              		.loc 1 208 0
 2878 063c 20309FE5 		ldr	r3, .L38+4
 2879 0640 1C209FE5 		ldr	r2, .L38+4
 2880 0644 002092E5 		ldr	r2, [r2, #0]
 2881 0648 022B82E3 		orr	r2, r2, #2048
 2882 064c 002083E5 		str	r2, [r3, #0]
 209:../timer.c    **** }
 2883              		.loc 1 209 0
 2884 0650 1CD04BE2 		sub	sp, fp, #28
 2885 0654 0F689DE8 		ldmfd	sp, {r0, r1, r2, r3, fp, sp, lr}
 2886 0658 04C09DE4 		ldmfd	sp!, {ip}
 2887 065c 04F05EE2 		subs	pc, lr, #4
 2888              	.L39:
 2889              		.align	2
 2890              	.L38:
 2891 0660 0C000000 		.word	led_status.4039
 2892 0664 2400E001 		.word	31457316
 2893              		.cfi_endproc
 2894              	.LFE7:
 2896              		.align	2
 2897              		.global	timer2_init
 2899              	timer2_init:
 2900              	.LFB8:
 210:../timer.c    **** 
 211:../timer.c    **** void timer2_init(void)
 212:../timer.c    **** {
 2901              		.loc 1 212 0
 2902              		.cfi_startproc
 2903              		@ Function supports interworking.
 2904              		@ args = 0, pretend = 0, frame = 0
 2905              		@ frame_needed = 1, uses_anonymous_args = 0
 2906 0668 0DC0A0E1 		mov	ip, sp
 2907              	.LCFI16:
 2908              		.cfi_def_cfa_register 12
 2909 066c 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2910 0670 04B04CE2 		sub	fp, ip, #4
 2911              		.cfi_offset 14, -8
 2912              		.cfi_offset 13, -12
 2913              		.cfi_offset 11, -16
 2914              	.LCFI17:
 2915              		.cfi_def_cfa 11, 4
 213:../timer.c    **** 	// Configuración del controlador de interrupciones
 214:../timer.c    **** 	rINTMOD = 0x0;						// Configura las líneas como de tipo IRQ
 2916              		.loc 1 214 0
 2917 0674 B0309FE5 		ldr	r3, .L41
 2918 0678 0020A0E3 		mov	r2, #0
 2919 067c 002083E5 		str	r2, [r3, #0]
 215:../timer.c    **** 	rINTCON = 0x1;						// Habilita interrupciones vectorizadas y la línea IRQ
 2920              		.loc 1 215 0
 2921 0680 1E36A0E3 		mov	r3, #31457280
 2922 0684 0120A0E3 		mov	r2, #1
 2923 0688 002083E5 		str	r2, [r3, #0]
 216:../timer.c    **** 	rINTMSK &= ~(BIT_TIMER2); // Habilitar interrupciones del timer2
 2924              		.loc 1 216 0
 2925 068c 9C309FE5 		ldr	r3, .L41+4
 2926 0690 98209FE5 		ldr	r2, .L41+4
 2927 0694 002092E5 		ldr	r2, [r2, #0]
 2928 0698 022BC2E3 		bic	r2, r2, #2048
 2929 069c 002083E5 		str	r2, [r3, #0]
 217:../timer.c    **** 
 218:../timer.c    **** 	// Establece la rutina de servicio para TIMER2
 219:../timer.c    **** 	pISR_TIMER2 = (unsigned)timer2_ISR;
 2930              		.loc 1 219 0
 2931 06a0 8C309FE5 		ldr	r3, .L41+8
 2932 06a4 8C209FE5 		ldr	r2, .L41+12
 2933 06a8 002083E5 		str	r2, [r3, #0]
 220:../timer.c    **** 
 221:../timer.c    **** 	// Configuración del Timer2
 222:../timer.c    **** 	// Usaremos una frecuencia más baja para asegurarnos de que el temporizador funciona como esperam
 223:../timer.c    **** 	rTCFG0 = 255;					 // Preescalado, para dividir la frecuencia de entrada
 2934              		.loc 1 223 0
 2935 06ac 88309FE5 		ldr	r3, .L41+16
 2936 06b0 FF20A0E3 		mov	r2, #255
 2937 06b4 002083E5 		str	r2, [r3, #0]
 224:../timer.c    **** 	rTCFG1 &= ~(0xf << 8); // Seleccionar un divisor de 1/2 para Timer2
 2938              		.loc 1 224 0
 2939 06b8 80309FE5 		ldr	r3, .L41+20
 2940 06bc 7C209FE5 		ldr	r2, .L41+20
 2941 06c0 002092E5 		ldr	r2, [r2, #0]
 2942 06c4 0F2CC2E3 		bic	r2, r2, #3840
 2943 06c8 002083E5 		str	r2, [r3, #0]
 225:../timer.c    **** 
 226:../timer.c    **** 	// Queremos 80 interrupciones por segundo, así que necesitamos calcular el valor para rTCNTB2
 227:../timer.c    **** 	// Si el reloj de entrada tiene una frecuencia de 50 MHz:
 228:../timer.c    **** 	// Frecuencia de reloj = 50,000,000 / (prescaler + 1) / divisor_mux
 229:../timer.c    **** 	//                      = 50,000,000 / 256 / 2
 230:../timer.c    **** 	//                      = 97656.25 Hz
 231:../timer.c    **** 	// Necesitamos 80 interrupciones por segundo:
 232:../timer.c    **** 	// Valor de rTCNTB2 = 97656.25 / 80 ≈ 1220
 233:../timer.c    **** 	rTCNTB2 = 1220; // Configuración para obtener la frecuencia de interrupción deseada
 2944              		.loc 1 233 0
 2945 06cc 70309FE5 		ldr	r3, .L41+24
 2946 06d0 70209FE5 		ldr	r2, .L41+28
 2947 06d4 002083E5 		str	r2, [r3, #0]
 234:../timer.c    **** 	rTCMPB2 = 0;		// No utilizamos el comparador en este caso
 2948              		.loc 1 234 0
 2949 06d8 6C309FE5 		ldr	r3, .L41+32
 2950 06dc 0020A0E3 		mov	r2, #0
 2951 06e0 002083E5 		str	r2, [r3, #0]
 235:../timer.c    **** 
 236:../timer.c    **** 	// Configurar update manual (bit 13) para cargar el valor del buffer y luego iniciar el timer
 237:../timer.c    **** 	rTCON |= (1 << 13);							// Establecer update=manual (bit 13)
 2952              		.loc 1 237 0
 2953 06e4 64309FE5 		ldr	r3, .L41+36
 2954 06e8 60209FE5 		ldr	r2, .L41+36
 2955 06ec 002092E5 		ldr	r2, [r2, #0]
 2956 06f0 022A82E3 		orr	r2, r2, #8192
 2957 06f4 002083E5 		str	r2, [r3, #0]
 238:../timer.c    **** 	rTCON &= ~(1 << 13);						// Desactivar el bit de update manual
 2958              		.loc 1 238 0
 2959 06f8 50309FE5 		ldr	r3, .L41+36
 2960 06fc 4C209FE5 		ldr	r2, .L41+36
 2961 0700 002092E5 		ldr	r2, [r2, #0]
 2962 0704 022AC2E3 		bic	r2, r2, #8192
 2963 0708 002083E5 		str	r2, [r3, #0]
 239:../timer.c    **** 	rTCON |= (1 << 12) | (1 << 15); // Iniciar el timer2 (bit 12) y habilitar auto-reload (bit 15)
 2964              		.loc 1 239 0
 2965 070c 3C309FE5 		ldr	r3, .L41+36
 2966 0710 38209FE5 		ldr	r2, .L41+36
 2967 0714 002092E5 		ldr	r2, [r2, #0]
 2968 0718 092A82E3 		orr	r2, r2, #36864
 2969 071c 002083E5 		str	r2, [r3, #0]
 240:../timer.c    **** }...
 2970              		.loc 1 240 0
 2971 0720 0CD04BE2 		sub	sp, fp, #12
 2972 0724 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2973 0728 1EFF2FE1 		bx	lr
 2974              	.L42:
 2975              		.align	2
 2976              	.L41:
 2977 072c 0800E001 		.word	31457288
 2978 0730 0C00E001 		.word	31457292
 2979 0734 4CFF7F0C 		.word	209715020
 2980 0738 00000000 		.word	timer2_ISR
 2981 073c 0000D501 		.word	30736384
 2982 0740 0400D501 		.word	30736388
 2983 0744 2400D501 		.word	30736420
 2984 0748 C4040000 		.word	1220
 2985 074c 2800D501 		.word	30736424
 2986 0750 0800D501 		.word	30736392
 2987              		.cfi_endproc
 2988              	.LFE8:
 2990              		.bss
 2991              		.align	2
 2992              	led_status.4039:
 2993 000c 00000000 		.space	4
 2994              		.text
 2995              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 timer.c
                            *COM*:00000004 switch_leds
C:\Users\Jorge\AppData\Local\Temp\cceMtuOj.s:2166   .bss:00000000 timer1_num_int
C:\Users\Jorge\AppData\Local\Temp\cceMtuOj.s:2163   .bss:00000000 $d
C:\Users\Jorge\AppData\Local\Temp\cceMtuOj.s:2172   .data:00000000 timer_event
C:\Users\Jorge\AppData\Local\Temp\cceMtuOj.s:2176   .data:00000001 evento
C:\Users\Jorge\AppData\Local\Temp\cceMtuOj.s:2180   .bss:00000004 led8_count
C:\Users\Jorge\AppData\Local\Temp\cceMtuOj.s:2183   .bss:00000008 button_id
C:\Users\Jorge\AppData\Local\Temp\cceMtuOj.s:2186   .text:00000000 $a
C:\Users\Jorge\AppData\Local\Temp\cceMtuOj.s:2189   .text:00000000 timer_ISR
C:\Users\Jorge\AppData\Local\Temp\cceMtuOj.s:2740   .text:00000560 timer1_leer
C:\Users\Jorge\AppData\Local\Temp\cceMtuOj.s:2445   .text:000002d4 $d
C:\Users\Jorge\AppData\Local\Temp\cceMtuOj.s:2456   .text:000002f4 $a
C:\Users\Jorge\AppData\Local\Temp\cceMtuOj.s:2459   .text:000002f4 timer_init
C:\Users\Jorge\AppData\Local\Temp\cceMtuOj.s:2525   .text:0000038c $d
C:\Users\Jorge\AppData\Local\Temp\cceMtuOj.s:2538   .text:000003b4 $a
C:\Users\Jorge\AppData\Local\Temp\cceMtuOj.s:2541   .text:000003b4 timer1_inicializar
C:\Users\Jorge\AppData\Local\Temp\cceMtuOj.s:2618   .text:00000474 $d
C:\Users\Jorge\AppData\Local\Temp\cceMtuOj.s:2633   .text:00000498 timer1_ISR
C:\Users\Jorge\AppData\Local\Temp\cceMtuOj.s:2630   .text:00000498 $a
C:\Users\Jorge\AppData\Local\Temp\cceMtuOj.s:2673   .text:000004e0 $d
C:\Users\Jorge\AppData\Local\Temp\cceMtuOj.s:2678   .text:000004e8 $a
C:\Users\Jorge\AppData\Local\Temp\cceMtuOj.s:2681   .text:000004e8 timer1_empezar
C:\Users\Jorge\AppData\Local\Temp\cceMtuOj.s:2731   .text:00000554 $d
C:\Users\Jorge\AppData\Local\Temp\cceMtuOj.s:2737   .text:00000560 $a
C:\Users\Jorge\AppData\Local\Temp\cceMtuOj.s:2782   .text:000005b4 $d
C:\Users\Jorge\AppData\Local\Temp\cceMtuOj.s:2787   .text:000005bc $a
C:\Users\Jorge\AppData\Local\Temp\cceMtuOj.s:2790   .text:000005bc timer1_parar
C:\Users\Jorge\AppData\Local\Temp\cceMtuOj.s:2824   .text:000005f4 $d
C:\Users\Jorge\AppData\Local\Temp\cceMtuOj.s:2828   .text:000005f8 $a
C:\Users\Jorge\AppData\Local\Temp\cceMtuOj.s:2831   .text:000005f8 timer2_ISR
C:\Users\Jorge\AppData\Local\Temp\cceMtuOj.s:2891   .text:00000660 $d
C:\Users\Jorge\AppData\Local\Temp\cceMtuOj.s:2992   .bss:0000000c led_status.4039
C:\Users\Jorge\AppData\Local\Temp\cceMtuOj.s:2896   .text:00000668 $a
C:\Users\Jorge\AppData\Local\Temp\cceMtuOj.s:2899   .text:00000668 timer2_init
C:\Users\Jorge\AppData\Local\Temp\cceMtuOj.s:2977   .text:0000072c $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
push_debug
D8Led_symbol
led2_on
led2_off
