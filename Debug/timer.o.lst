   1              		.cpu arm7tdmi
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 18, 4
  11              		.file	"timer.c"
  21              	.Ltext0:
  22              		.file 1 "../timer.c"
 2747              		.align	2
 2750              	timer1_num_int:
 2751 0000 00000000 		.space	4
 2752              		.global	led_event_counter
 2753              		.align	2
 2756              	led_event_counter:
 2757 0004 00000000 		.space	4
 2758              		.align	2
 2759              	selected_row:
 2760 0008 00000000 		.space	4
 2761              		.align	2
 2762              	selected_column:
 2763 000c 00000000 		.space	4
 2764              		.text
 2765              		.align	2
 2766              		.global	timer_ISR
 2768              	timer_ISR:
 2769              	.LFB0:
   1:../timer.c    **** /*********************************************************************************************
   2:../timer.c    ****  * Fichero:		timer.c
   3:../timer.c    ****  * Autor:
   4:../timer.c    ****  * Descrip:		funciones de control del timer0 del s3c44b0x
   5:../timer.c    ****  * Version:
   6:../timer.c    ****  *********************************************************************************************/
   7:../timer.c    **** 
   8:../timer.c    **** /*--- ficheros de cabecera ---*/
   9:../timer.c    **** #include "timer.h"
  10:../timer.c    **** #include "44b.h"
  11:../timer.c    **** #include "44blib.h"
  12:../timer.c    **** #include "eventos.h"
  13:../timer.c    **** #include "sudoku_2024.h"
  14:../timer.c    **** 
  15:../timer.c    **** /*--- variables globales ---*/
  16:../timer.c    **** extern int switch_leds;
  17:../timer.c    **** int timer1_num_int = 0; // Contador de periodos completos por el timer1
  18:../timer.c    **** volatile int led_event_counter = 0;
  19:../timer.c    **** extern CELDA cuadricula[NUM_FILAS][NUM_COLUMNAS];
  20:../timer.c    **** static int selected_row = 0;
  21:../timer.c    **** static int selected_column = 0;
  22:../timer.c    **** 
  23:../timer.c    **** /* declaraci�n de funci�n que es rutina de servicio de interrupci�n
  24:../timer.c    **** https://gcc.gnu.org/onlinedocs/gcc/ARM-Function-Attributes.html */
  25:../timer.c    **** void timer_ISR(void) __attribute__((interrupt("IRQ")));
  26:../timer.c    **** void timer1_ISR(void) __attribute__((interrupt("IRQ")));
  27:../timer.c    **** void timer2_ISR(void) __attribute__((interrupt("IRQ")));
  28:../timer.c    **** 
  29:../timer.c    **** /*--- codigo de las funciones ---*/
  30:../timer.c    **** void timer_ISR(void)
  31:../timer.c    **** {
 2770              		.loc 1 31 0
 2771              		.cfi_startproc
 2772              		@ Interrupt Service Routine.
 2773              		@ args = 0, pretend = 0, frame = 0
 2774              		@ frame_needed = 1, uses_anonymous_args = 0
 2775 0000 04C02DE5 		str	ip, [sp, #-4]!
 2776 0004 0DC0A0E1 		mov	ip, sp
 2777              	.LCFI0:
 2778              		.cfi_def_cfa_register 12
 2779 0008 0CD82DE9 		stmfd	sp!, {r2, r3, fp, ip, lr, pc}
 2780 000c 04B04CE2 		sub	fp, ip, #4
 2781              		.cfi_offset 14, -8
 2782              		.cfi_offset 13, -12
 2783              		.cfi_offset 11, -16
 2784              		.cfi_offset 3, -20
 2785              		.cfi_offset 2, -24
 2786              	.LCFI1:
 2787              		.cfi_def_cfa 11, 4
  32:../timer.c    **** 	switch_leds = 1;
 2788              		.loc 1 32 0
 2789 0010 28309FE5 		ldr	r3, .L2
 2790 0014 0120A0E3 		mov	r2, #1
 2791 0018 002083E5 		str	r2, [r3, #0]
  33:../timer.c    **** 
  34:../timer.c    **** 	/* borrar bit en I_ISPC para desactivar la solicitud de interrupci�n*/
  35:../timer.c    **** 	rI_ISPC |= BIT_TIMER0; // BIT_TIMER0 est� definido en 44b.h y pone un uno en el bit 13 que corre
 2792              		.loc 1 35 0
 2793 001c 20309FE5 		ldr	r3, .L2+4
 2794 0020 1C209FE5 		ldr	r2, .L2+4
 2795 0024 002092E5 		ldr	r2, [r2, #0]
 2796 0028 022A82E3 		orr	r2, r2, #8192
 2797 002c 002083E5 		str	r2, [r3, #0]
  36:../timer.c    **** }
 2798              		.loc 1 36 0
 2799 0030 14D04BE2 		sub	sp, fp, #20
 2800 0034 0C689DE8 		ldmfd	sp, {r2, r3, fp, sp, lr}
 2801 0038 04C09DE4 		ldmfd	sp!, {ip}
 2802 003c 04F05EE2 		subs	pc, lr, #4
 2803              	.L3:
 2804              		.align	2
 2805              	.L2:
 2806 0040 00000000 		.word	switch_leds
 2807 0044 2400E001 		.word	31457316
 2808              		.cfi_endproc
 2809              	.LFE0:
 2811              		.align	2
 2812              		.global	timer_init
 2814              	timer_init:
 2815              	.LFB1:
  37:../timer.c    **** 
  38:../timer.c    **** void timer_init(void)
  39:../timer.c    **** {
 2816              		.loc 1 39 0
 2817              		.cfi_startproc
 2818              		@ Function supports interworking.
 2819              		@ args = 0, pretend = 0, frame = 0
 2820              		@ frame_needed = 1, uses_anonymous_args = 0
 2821 0048 0DC0A0E1 		mov	ip, sp
 2822              	.LCFI2:
 2823              		.cfi_def_cfa_register 12
 2824 004c 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2825 0050 04B04CE2 		sub	fp, ip, #4
 2826              		.cfi_offset 14, -8
 2827              		.cfi_offset 13, -12
 2828              		.cfi_offset 11, -16
 2829              	.LCFI3:
 2830              		.cfi_def_cfa 11, 4
  40:../timer.c    **** 	/* Configuracion controlador de interrupciones */
  41:../timer.c    **** 	rINTMOD = 0x0;						// Configura las lineas como de tipo IRQ
 2831              		.loc 1 41 0
 2832 0054 84309FE5 		ldr	r3, .L5
 2833 0058 0020A0E3 		mov	r2, #0
 2834 005c 002083E5 		str	r2, [r3, #0]
  42:../timer.c    **** 	rINTCON = 0x1;						// Habilita int. vectorizadas y la linea IRQ (FIQ no)
 2835              		.loc 1 42 0
 2836 0060 1E36A0E3 		mov	r3, #31457280
 2837 0064 0120A0E3 		mov	r2, #1
 2838 0068 002083E5 		str	r2, [r3, #0]
  43:../timer.c    **** 	rINTMSK &= ~(BIT_TIMER0); // habilitamos en vector de mascaras de interrupcion el Timer0 (bits 26 
 2839              		.loc 1 43 0
 2840 006c 70309FE5 		ldr	r3, .L5+4
 2841 0070 6C209FE5 		ldr	r2, .L5+4
 2842 0074 002092E5 		ldr	r2, [r2, #0]
 2843 0078 022AC2E3 		bic	r2, r2, #8192
 2844 007c 002083E5 		str	r2, [r3, #0]
  44:../timer.c    **** 
  45:../timer.c    **** 	/* Establece la rutina de servicio para TIMER0 */
  46:../timer.c    **** 	pISR_TIMER0 = (unsigned)timer_ISR;
 2845              		.loc 1 46 0
 2846 0080 60309FE5 		ldr	r3, .L5+8
 2847 0084 60209FE5 		ldr	r2, .L5+12
 2848 0088 002083E5 		str	r2, [r3, #0]
  47:../timer.c    **** 
  48:../timer.c    **** 	/* Configura el Timer0 */
  49:../timer.c    **** 	rTCFG0 = 255;		 // ajusta el preescalado
 2849              		.loc 1 49 0
 2850 008c 5C309FE5 		ldr	r3, .L5+16
 2851 0090 FF20A0E3 		mov	r2, #255
 2852 0094 002083E5 		str	r2, [r3, #0]
  50:../timer.c    **** 	rTCFG1 = 0x0;		 // selecciona la entrada del mux que proporciona el reloj. La 00 corresponde a un 
 2853              		.loc 1 50 0
 2854 0098 54309FE5 		ldr	r3, .L5+20
 2855 009c 0020A0E3 		mov	r2, #0
 2856 00a0 002083E5 		str	r2, [r3, #0]
  51:../timer.c    **** 	rTCNTB0 = 65535; // valor inicial de cuenta (la cuenta es descendente)
 2857              		.loc 1 51 0
 2858 00a4 4C309FE5 		ldr	r3, .L5+24
 2859 00a8 4C209FE5 		ldr	r2, .L5+28
 2860 00ac 002083E5 		str	r2, [r3, #0]
  52:../timer.c    **** 	rTCMPB0 = 12800; // valor de comparaci�n
 2861              		.loc 1 52 0
 2862 00b0 48309FE5 		ldr	r3, .L5+32
 2863 00b4 322CA0E3 		mov	r2, #12800
 2864 00b8 002083E5 		str	r2, [r3, #0]
  53:../timer.c    **** 	/* establecer update=manual (bit 1) + inverter=on (�? ser� inverter off un cero en el bit 2 po
  54:../timer.c    **** 	rTCON = 0x2;
 2865              		.loc 1 54 0
 2866 00bc 40309FE5 		ldr	r3, .L5+36
 2867 00c0 0220A0E3 		mov	r2, #2
 2868 00c4 002083E5 		str	r2, [r3, #0]
  55:../timer.c    **** 	/* iniciar timer (bit 0) con auto-reload (bit 3)*/
  56:../timer.c    **** 	rTCON = 0x09;
 2869              		.loc 1 56 0
 2870 00c8 34309FE5 		ldr	r3, .L5+36
 2871 00cc 0920A0E3 		mov	r2, #9
 2872 00d0 002083E5 		str	r2, [r3, #0]
  57:../timer.c    **** }
 2873              		.loc 1 57 0
 2874 00d4 0CD04BE2 		sub	sp, fp, #12
 2875 00d8 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2876 00dc 1EFF2FE1 		bx	lr
 2877              	.L6:
 2878              		.align	2
 2879              	.L5:
 2880 00e0 0800E001 		.word	31457288
 2881 00e4 0C00E001 		.word	31457292
 2882 00e8 54FF7F0C 		.word	209715028
 2883 00ec 00000000 		.word	timer_ISR
 2884 00f0 0000D501 		.word	30736384
 2885 00f4 0400D501 		.word	30736388
 2886 00f8 0C00D501 		.word	30736396
 2887 00fc FFFF0000 		.word	65535
 2888 0100 1000D501 		.word	30736400
 2889 0104 0800D501 		.word	30736392
 2890              		.cfi_endproc
 2891              	.LFE1:
 2893              		.align	2
 2894              		.global	timer1_inicializar
 2896              	timer1_inicializar:
 2897              	.LFB2:
  58:../timer.c    **** 
  59:../timer.c    **** void timer1_inicializar(void)
  60:../timer.c    **** {
 2898              		.loc 1 60 0
 2899              		.cfi_startproc
 2900              		@ Function supports interworking.
 2901              		@ args = 0, pretend = 0, frame = 0
 2902              		@ frame_needed = 1, uses_anonymous_args = 0
 2903 0108 0DC0A0E1 		mov	ip, sp
 2904              	.LCFI4:
 2905              		.cfi_def_cfa_register 12
 2906 010c 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2907 0110 04B04CE2 		sub	fp, ip, #4
 2908              		.cfi_offset 14, -8
 2909              		.cfi_offset 13, -12
 2910              		.cfi_offset 11, -16
 2911              	.LCFI5:
 2912              		.cfi_def_cfa 11, 4
  61:../timer.c    **** 	rINTMOD = 0x0; // Configura las lineas como de tipo IRQ
 2913              		.loc 1 61 0
 2914 0114 AC309FE5 		ldr	r3, .L8
 2915 0118 0020A0E3 		mov	r2, #0
 2916 011c 002083E5 		str	r2, [r3, #0]
  62:../timer.c    **** 	rINTCON = 0x1; // Habilita int. vectorizadas y la linea IRQ (FIQ no)
 2917              		.loc 1 62 0
 2918 0120 1E36A0E3 		mov	r3, #31457280
 2919 0124 0120A0E3 		mov	r2, #1
 2920 0128 002083E5 		str	r2, [r3, #0]
  63:../timer.c    **** 	rINTMSK &= ~(BIT_TIMER1);
 2921              		.loc 1 63 0
 2922 012c 98309FE5 		ldr	r3, .L8+4
 2923 0130 94209FE5 		ldr	r2, .L8+4
 2924 0134 002092E5 		ldr	r2, [r2, #0]
 2925 0138 012AC2E3 		bic	r2, r2, #4096
 2926 013c 002083E5 		str	r2, [r3, #0]
  64:../timer.c    **** 
  65:../timer.c    **** 	pISR_TIMER1 = (unsigned)timer1_ISR;
 2927              		.loc 1 65 0
 2928 0140 88309FE5 		ldr	r3, .L8+8
 2929 0144 88209FE5 		ldr	r2, .L8+12
 2930 0148 002083E5 		str	r2, [r3, #0]
  66:../timer.c    **** 
  67:../timer.c    **** 	// Configuracion del Timer1
  68:../timer.c    **** 	rTCFG0 = 255;
 2931              		.loc 1 68 0
 2932 014c 84309FE5 		ldr	r3, .L8+16
 2933 0150 FF20A0E3 		mov	r2, #255
 2934 0154 002083E5 		str	r2, [r3, #0]
  69:../timer.c    **** 	rTCFG1 = 0x0;
 2935              		.loc 1 69 0
 2936 0158 7C309FE5 		ldr	r3, .L8+20
 2937 015c 0020A0E3 		mov	r2, #0
 2938 0160 002083E5 		str	r2, [r3, #0]
  70:../timer.c    **** 
  71:../timer.c    **** 	rTCNTB1 = 64000;
 2939              		.loc 1 71 0
 2940 0164 74309FE5 		ldr	r3, .L8+24
 2941 0168 FA2CA0E3 		mov	r2, #64000
 2942 016c 002083E5 		str	r2, [r3, #0]
  72:../timer.c    **** 	rTCMPB1 = 0x0;
 2943              		.loc 1 72 0
 2944 0170 6C309FE5 		ldr	r3, .L8+28
 2945 0174 0020A0E3 		mov	r2, #0
 2946 0178 002083E5 		str	r2, [r3, #0]
  73:../timer.c    **** 
  74:../timer.c    **** 	rTCON |= (1 << 9);																				// Set bit 9 (update=manual)
 2947              		.loc 1 74 0
 2948 017c 64309FE5 		ldr	r3, .L8+32
 2949 0180 60209FE5 		ldr	r2, .L8+32
 2950 0184 002092E5 		ldr	r2, [r2, #0]
 2951 0188 022C82E3 		orr	r2, r2, #512
 2952 018c 002083E5 		str	r2, [r3, #0]
  75:../timer.c    **** 	rTCON &= ~(1 << 11);																			// Clear bit 11 (auto-reload off)
 2953              		.loc 1 75 0
 2954 0190 50309FE5 		ldr	r3, .L8+32
 2955 0194 4C209FE5 		ldr	r2, .L8+32
 2956 0198 002092E5 		ldr	r2, [r2, #0]
 2957 019c 022BC2E3 		bic	r2, r2, #2048
 2958 01a0 002083E5 		str	r2, [r3, #0]
  76:../timer.c    **** 	rTCON = (rTCON & ~(0x1 << 9)) | (0x1 << 11) | (0x1 << 8); // Clear bit 9 and set bit 11 (update=ma
 2959              		.loc 1 76 0
 2960 01a4 3C309FE5 		ldr	r3, .L8+32
 2961 01a8 38209FE5 		ldr	r2, .L8+32
 2962 01ac 002092E5 		ldr	r2, [r2, #0]
 2963 01b0 0B2CC2E3 		bic	r2, r2, #2816
 2964 01b4 092C82E3 		orr	r2, r2, #2304
 2965 01b8 002083E5 		str	r2, [r3, #0]
  77:../timer.c    **** }
 2966              		.loc 1 77 0
 2967 01bc 0CD04BE2 		sub	sp, fp, #12
 2968 01c0 00689DE8 		ldmfd	sp, {fp, sp, lr}
 2969 01c4 1EFF2FE1 		bx	lr
 2970              	.L9:
 2971              		.align	2
 2972              	.L8:
 2973 01c8 0800E001 		.word	31457288
 2974 01cc 0C00E001 		.word	31457292
 2975 01d0 50FF7F0C 		.word	209715024
 2976 01d4 00000000 		.word	timer1_ISR
 2977 01d8 0000D501 		.word	30736384
 2978 01dc 0400D501 		.word	30736388
 2979 01e0 1800D501 		.word	30736408
 2980 01e4 1C00D501 		.word	30736412
 2981 01e8 0800D501 		.word	30736392
 2982              		.cfi_endproc
 2983              	.LFE2:
 2985              		.align	2
 2986              		.global	timer1_ISR
 2988              	timer1_ISR:
 2989              	.LFB3:
  78:../timer.c    **** 
  79:../timer.c    **** void timer1_ISR(void)
  80:../timer.c    **** {
 2990              		.loc 1 80 0
 2991              		.cfi_startproc
 2992              		@ Interrupt Service Routine.
 2993              		@ args = 0, pretend = 0, frame = 0
 2994              		@ frame_needed = 1, uses_anonymous_args = 0
 2995 01ec 04C02DE5 		str	ip, [sp, #-4]!
 2996 01f0 0DC0A0E1 		mov	ip, sp
 2997              	.LCFI6:
 2998              		.cfi_def_cfa_register 12
 2999 01f4 3FD82DE9 		stmfd	sp!, {r0, r1, r2, r3, r4, r5, fp, ip, lr, pc}
 3000 01f8 04B04CE2 		sub	fp, ip, #4
 3001              		.cfi_offset 14, -8
 3002              		.cfi_offset 13, -12
 3003              		.cfi_offset 11, -16
 3004              		.cfi_offset 5, -20
 3005              		.cfi_offset 4, -24
 3006              		.cfi_offset 3, -28
 3007              		.cfi_offset 2, -32
 3008              		.cfi_offset 1, -36
 3009              		.cfi_offset 0, -40
 3010              	.LCFI7:
 3011              		.cfi_def_cfa 11, 4
  81:../timer.c    **** 	timer1_num_int++; // Incrementar el contador de ciclos completos
 3012              		.loc 1 81 0
 3013 01fc 44359FE5 		ldr	r3, .L51
 3014 0200 003093E5 		ldr	r3, [r3, #0]
 3015 0204 012083E2 		add	r2, r3, #1
 3016 0208 38359FE5 		ldr	r3, .L51
 3017 020c 002083E5 		str	r2, [r3, #0]
  82:../timer.c    **** 	// Máquina de estados
  83:../timer.c    **** 	switch (button_state)
 3018              		.loc 1 83 0
 3019 0210 34359FE5 		ldr	r3, .L51+4
 3020 0214 0030D3E5 		ldrb	r3, [r3, #0]
 3021 0218 FF3003E2 		and	r3, r3, #255
 3022 021c 030053E3 		cmp	r3, #3
 3023 0220 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 3024 0224 2F0100EA 		b	.L11
 3025              	.L16:
 3026 0228 38020000 		.word	.L12
 3027 022c 74020000 		.word	.L13
 3028 0230 7C060000 		.word	.L14
 3029 0234 14060000 		.word	.L15
 3030              	.L12:
  84:../timer.c    **** 	{
  85:../timer.c    **** 	case WAITING:
  86:../timer.c    **** 		if (button_flag == 1) // Detectar una nueva pulsación
 3031              		.loc 1 86 0
 3032 0238 10359FE5 		ldr	r3, .L51+8
 3033 023c 003093E5 		ldr	r3, [r3, #0]
 3034 0240 010053E3 		cmp	r3, #1
 3035 0244 2B01001A 		bne	.L41
  87:../timer.c    **** 		{
  88:../timer.c    **** 			button_state = PRESSED;
 3036              		.loc 1 88 0
 3037 0248 FC349FE5 		ldr	r3, .L51+4
 3038 024c 0120A0E3 		mov	r2, #1
 3039 0250 0020C3E5 		strb	r2, [r3, #0]
  89:../timer.c    **** 			last_timer_value = timer1_leer();
 3040              		.loc 1 89 0
 3041 0254 FEFFFFEB 		bl	timer1_leer
 3042 0258 0020A0E1 		mov	r2, r0
 3043 025c F0349FE5 		ldr	r3, .L51+12
 3044 0260 002083E5 		str	r2, [r3, #0]
  90:../timer.c    **** 			button_flag = 0;
 3045              		.loc 1 90 0
 3046 0264 E4349FE5 		ldr	r3, .L51+8
 3047 0268 0020A0E3 		mov	r2, #0
 3048 026c 002083E5 		str	r2, [r3, #0]
  91:../timer.c    **** 		}
  92:../timer.c    **** 		break;
 3049              		.loc 1 92 0
 3050 0270 2B0100EA 		b	.L18
 3051              	.L13:
  93:../timer.c    **** 
  94:../timer.c    **** 	case PRESSED:
  95:../timer.c    **** 		if ((timer1_leer() - last_timer_value) > 272016) // TRP
 3052              		.loc 1 95 0
 3053 0274 FEFFFFEB 		bl	timer1_leer
 3054 0278 0020A0E1 		mov	r2, r0
 3055 027c D0349FE5 		ldr	r3, .L51+12
 3056 0280 003093E5 		ldr	r3, [r3, #0]
 3057 0284 022063E0 		rsb	r2, r3, r2
 3058 0288 C8349FE5 		ldr	r3, .L51+16
 3059 028c 030052E1 		cmp	r2, r3
 3060 0290 1A01009A 		bls	.L42
 3061              	.LBB2:
  96:../timer.c    **** 		{
  97:../timer.c    **** 
  98:../timer.c    **** 			switch (sudoku_status)
 3062              		.loc 1 98 0
 3063 0294 C0349FE5 		ldr	r3, .L51+20
 3064 0298 0030D3E5 		ldrb	r3, [r3, #0]
 3065 029c FF3003E2 		and	r3, r3, #255
 3066 02a0 040053E3 		cmp	r3, #4
 3067 02a4 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 3068 02a8 B70000EA 		b	.L43
 3069              	.L26:
 3070 02ac 8C050000 		.word	.L43
 3071 02b0 C0020000 		.word	.L22
 3072 02b4 E8020000 		.word	.L23
 3073 02b8 70030000 		.word	.L24
 3074 02bc 54040000 		.word	.L25
 3075              	.L22:
  99:../timer.c    **** 			{
 100:../timer.c    **** 			case NOT_STARTED:
 101:../timer.c    **** 				break;
 102:../timer.c    **** 			case STARTED:
 103:../timer.c    **** 				sudoku_candidatos_init_c(cuadricula, 0);
 3076              		.loc 1 103 0
 3077 02c0 98049FE5 		ldr	r0, .L51+24
 3078 02c4 0010A0E3 		mov	r1, #0
 3079 02c8 FEFFFFEB 		bl	sudoku_candidatos_init_c
 104:../timer.c    **** 				led8_count = 15;
 3080              		.loc 1 104 0
 3081 02cc 90349FE5 		ldr	r3, .L51+28
 3082 02d0 0F20A0E3 		mov	r2, #15
 3083 02d4 002083E5 		str	r2, [r3, #0]
 105:../timer.c    **** 				sudoku_status = ROW_SELECTION;
 3084              		.loc 1 105 0
 3085 02d8 7C349FE5 		ldr	r3, .L51+20
 3086 02dc 0220A0E3 		mov	r2, #2
 3087 02e0 0020C3E5 		strb	r2, [r3, #0]
 106:../timer.c    **** 				break;
 3088              		.loc 1 106 0
 3089 02e4 AF0000EA 		b	.L27
 3090              	.L23:
 107:../timer.c    **** 			case ROW_SELECTION:
 108:../timer.c    **** 				if (!(rPDATG & 0x40)) // Incrementar con el boton izquierdo
 3091              		.loc 1 108 0
 3092 02e8 78349FE5 		ldr	r3, .L51+32
 3093 02ec 003093E5 		ldr	r3, [r3, #0]
 3094 02f0 403003E2 		and	r3, r3, #64
 3095 02f4 000053E3 		cmp	r3, #0
 3096 02f8 0B00001A 		bne	.L28
 109:../timer.c    **** 				{
 110:../timer.c    **** 					led8_count++;
 3097              		.loc 1 110 0
 3098 02fc 60349FE5 		ldr	r3, .L51+28
 3099 0300 003093E5 		ldr	r3, [r3, #0]
 3100 0304 012083E2 		add	r2, r3, #1
 3101 0308 54349FE5 		ldr	r3, .L51+28
 3102 030c 002083E5 		str	r2, [r3, #0]
 111:../timer.c    **** 
 112:../timer.c    **** 					if (led8_count > 9)
 3103              		.loc 1 112 0
 3104 0310 4C349FE5 		ldr	r3, .L51+28
 3105 0314 003093E5 		ldr	r3, [r3, #0]
 3106 0318 090053E3 		cmp	r3, #9
 3107 031c 020000DA 		ble	.L28
 113:../timer.c    **** 					{
 114:../timer.c    **** 						led8_count = 1;
 3108              		.loc 1 114 0
 3109 0320 3C349FE5 		ldr	r3, .L51+28
 3110 0324 0120A0E3 		mov	r2, #1
 3111 0328 002083E5 		str	r2, [r3, #0]
 3112              	.L28:
 115:../timer.c    **** 					}
 116:../timer.c    **** 				}
 117:../timer.c    **** 
 118:../timer.c    **** 				if (!(rPDATG & 0x80))
 3113              		.loc 1 118 0
 3114 032c 34349FE5 		ldr	r3, .L51+32
 3115 0330 003093E5 		ldr	r3, [r3, #0]
 3116 0334 803003E2 		and	r3, r3, #128
 3117 0338 000053E3 		cmp	r3, #0
 3118 033c 9400001A 		bne	.L44
 119:../timer.c    **** 				{
 120:../timer.c    **** 					selected_row = led8_count - 1; // Se resta uno para que el índice sea correcto (empezamos en 
 3119              		.loc 1 120 0
 3120 0340 1C349FE5 		ldr	r3, .L51+28
 3121 0344 003093E5 		ldr	r3, [r3, #0]
 3122 0348 012043E2 		sub	r2, r3, #1
 3123 034c 18349FE5 		ldr	r3, .L51+36
 3124 0350 002083E5 		str	r2, [r3, #0]
 121:../timer.c    **** 					led8_count = 12;
 3125              		.loc 1 121 0
 3126 0354 08349FE5 		ldr	r3, .L51+28
 3127 0358 0C20A0E3 		mov	r2, #12
 3128 035c 002083E5 		str	r2, [r3, #0]
 122:../timer.c    **** 					sudoku_status = COLUMN_SELECTION;
 3129              		.loc 1 122 0
 3130 0360 F4339FE5 		ldr	r3, .L51+20
 3131 0364 0320A0E3 		mov	r2, #3
 3132 0368 0020C3E5 		strb	r2, [r3, #0]
 123:../timer.c    **** 				}
 124:../timer.c    **** 				break;
 3133              		.loc 1 124 0
 3134 036c 8D0000EA 		b	.L27
 3135              	.L24:
 125:../timer.c    **** 			case COLUMN_SELECTION:
 126:../timer.c    **** 				if (!(rPDATG & 0x40)) // Incrementar con el boton izquierdo
 3136              		.loc 1 126 0
 3137 0370 F0339FE5 		ldr	r3, .L51+32
 3138 0374 003093E5 		ldr	r3, [r3, #0]
 3139 0378 403003E2 		and	r3, r3, #64
 3140 037c 000053E3 		cmp	r3, #0
 3141 0380 0B00001A 		bne	.L30
 127:../timer.c    **** 				{
 128:../timer.c    **** 					led8_count++;
 3142              		.loc 1 128 0
 3143 0384 D8339FE5 		ldr	r3, .L51+28
 3144 0388 003093E5 		ldr	r3, [r3, #0]
 3145 038c 012083E2 		add	r2, r3, #1
 3146 0390 CC339FE5 		ldr	r3, .L51+28
 3147 0394 002083E5 		str	r2, [r3, #0]
 129:../timer.c    **** 
 130:../timer.c    **** 					if (led8_count > 9)
 3148              		.loc 1 130 0
 3149 0398 C4339FE5 		ldr	r3, .L51+28
 3150 039c 003093E5 		ldr	r3, [r3, #0]
 3151 03a0 090053E3 		cmp	r3, #9
 3152 03a4 020000DA 		ble	.L30
 131:../timer.c    **** 					{
 132:../timer.c    **** 						led8_count = 1;
 3153              		.loc 1 132 0
 3154 03a8 B4339FE5 		ldr	r3, .L51+28
 3155 03ac 0120A0E3 		mov	r2, #1
 3156 03b0 002083E5 		str	r2, [r3, #0]
 3157              	.L30:
 133:../timer.c    **** 					}
 134:../timer.c    **** 				}
 135:../timer.c    **** 
 136:../timer.c    **** 				if (!(rPDATG & 0x80))
 3158              		.loc 1 136 0
 3159 03b4 AC339FE5 		ldr	r3, .L51+32
 3160 03b8 003093E5 		ldr	r3, [r3, #0]
 3161 03bc 803003E2 		and	r3, r3, #128
 3162 03c0 000053E3 		cmp	r3, #0
 3163 03c4 7400001A 		bne	.L45
 137:../timer.c    **** 				{
 138:../timer.c    **** 					selected_column = led8_count - 1; // Se resta uno para que el índice sea correcto (empezamos 
 3164              		.loc 1 138 0
 3165 03c8 94339FE5 		ldr	r3, .L51+28
 3166 03cc 003093E5 		ldr	r3, [r3, #0]
 3167 03d0 012043E2 		sub	r2, r3, #1
 3168 03d4 94339FE5 		ldr	r3, .L51+40
 3169 03d8 002083E5 		str	r2, [r3, #0]
 139:../timer.c    **** 
 140:../timer.c    **** 					if (cuadricula[selected_row][selected_column] & 0x8000) // comprobar si la celda es una pista
 3170              		.loc 1 140 0
 3171 03dc 88339FE5 		ldr	r3, .L51+36
 3172 03e0 001093E5 		ldr	r1, [r3, #0]
 3173 03e4 84339FE5 		ldr	r3, .L51+40
 3174 03e8 003093E5 		ldr	r3, [r3, #0]
 3175 03ec 6C239FE5 		ldr	r2, .L51+24
 3176 03f0 0112A0E1 		mov	r1, r1, asl #4
 3177 03f4 033081E0 		add	r3, r1, r3
 3178 03f8 8330A0E1 		mov	r3, r3, asl #1
 3179 03fc 033082E0 		add	r3, r2, r3
 3180 0400 B030D3E1 		ldrh	r3, [r3, #0]
 3181 0404 0338A0E1 		mov	r3, r3, asl #16
 3182 0408 2338A0E1 		mov	r3, r3, lsr #16
 3183 040c 0338A0E1 		mov	r3, r3, asl #16
 3184 0410 4338A0E1 		mov	r3, r3, asr #16
 3185 0414 000053E3 		cmp	r3, #0
 3186 0418 060000AA 		bge	.L32
 141:../timer.c    **** 					{
 142:../timer.c    **** 						sudoku_status = ROW_SELECTION;
 3187              		.loc 1 142 0
 3188 041c 38339FE5 		ldr	r3, .L51+20
 3189 0420 0220A0E3 		mov	r2, #2
 3190 0424 0020C3E5 		strb	r2, [r3, #0]
 143:../timer.c    **** 						led8_count = 15;
 3191              		.loc 1 143 0
 3192 0428 34339FE5 		ldr	r3, .L51+28
 3193 042c 0F20A0E3 		mov	r2, #15
 3194 0430 002083E5 		str	r2, [r3, #0]
 144:../timer.c    **** 					}
 145:../timer.c    **** 					else
 146:../timer.c    **** 					{
 147:../timer.c    **** 						sudoku_status = VALUE_SELECTION;
 148:../timer.c    **** 						led8_count = 0;
 149:../timer.c    **** 					}
 150:../timer.c    **** 				}
 151:../timer.c    **** 				break;
 3195              		.loc 1 151 0
 3196 0434 5B0000EA 		b	.L27
 3197              	.L32:
 147:../timer.c    **** 						sudoku_status = VALUE_SELECTION;
 3198              		.loc 1 147 0
 3199 0438 1C339FE5 		ldr	r3, .L51+20
 3200 043c 0420A0E3 		mov	r2, #4
 3201 0440 0020C3E5 		strb	r2, [r3, #0]
 148:../timer.c    **** 						led8_count = 0;
 3202              		.loc 1 148 0
 3203 0444 18339FE5 		ldr	r3, .L51+28
 3204 0448 0020A0E3 		mov	r2, #0
 3205 044c 002083E5 		str	r2, [r3, #0]
 3206              		.loc 1 151 0
 3207 0450 540000EA 		b	.L27
 3208              	.L25:
 152:../timer.c    **** 			case VALUE_SELECTION:
 153:../timer.c    **** 				if (!(rPDATG & 0x40)) // Incrementar con el boton izquierdo
 3209              		.loc 1 153 0
 3210 0454 0C339FE5 		ldr	r3, .L51+32
 3211 0458 003093E5 		ldr	r3, [r3, #0]
 3212 045c 403003E2 		and	r3, r3, #64
 3213 0460 000053E3 		cmp	r3, #0
 3214 0464 0B00001A 		bne	.L33
 154:../timer.c    **** 				{
 155:../timer.c    **** 					led8_count++;
 3215              		.loc 1 155 0
 3216 0468 F4329FE5 		ldr	r3, .L51+28
 3217 046c 003093E5 		ldr	r3, [r3, #0]
 3218 0470 012083E2 		add	r2, r3, #1
 3219 0474 E8329FE5 		ldr	r3, .L51+28
 3220 0478 002083E5 		str	r2, [r3, #0]
 156:../timer.c    **** 					if (led8_count > 9)
 3221              		.loc 1 156 0
 3222 047c E0329FE5 		ldr	r3, .L51+28
 3223 0480 003093E5 		ldr	r3, [r3, #0]
 3224 0484 090053E3 		cmp	r3, #9
 3225 0488 020000DA 		ble	.L33
 157:../timer.c    **** 					{
 158:../timer.c    **** 						led8_count = 0;
 3226              		.loc 1 158 0
 3227 048c D0329FE5 		ldr	r3, .L51+28
 3228 0490 0020A0E3 		mov	r2, #0
 3229 0494 002083E5 		str	r2, [r3, #0]
 3230              	.L33:
 159:../timer.c    **** 					}
 160:../timer.c    **** 				}
 161:../timer.c    **** 
 162:../timer.c    **** 				if (!(rPDATG & 0x80))
 3231              		.loc 1 162 0
 3232 0498 C8329FE5 		ldr	r3, .L51+32
 3233 049c 003093E5 		ldr	r3, [r3, #0]
 3234 04a0 803003E2 		and	r3, r3, #128
 3235 04a4 000053E3 		cmp	r3, #0
 3236 04a8 3D00001A 		bne	.L46
 163:../timer.c    **** 				{
 164:../timer.c    **** 					celda_poner_valor(&cuadricula[selected_row][selected_column], led8_count);
 3237              		.loc 1 164 0
 3238 04ac AC229FE5 		ldr	r2, .L51+24
 3239 04b0 B4329FE5 		ldr	r3, .L51+36
 3240 04b4 003093E5 		ldr	r3, [r3, #0]
 3241 04b8 0312A0E1 		mov	r1, r3, asl #4
 3242 04bc AC329FE5 		ldr	r3, .L51+40
 3243 04c0 003093E5 		ldr	r3, [r3, #0]
 3244 04c4 033081E0 		add	r3, r1, r3
 3245 04c8 8330A0E1 		mov	r3, r3, asl #1
 3246 04cc 032082E0 		add	r2, r2, r3
 3247 04d0 8C329FE5 		ldr	r3, .L51+28
 3248 04d4 003093E5 		ldr	r3, [r3, #0]
 3249 04d8 FF3003E2 		and	r3, r3, #255
 3250 04dc 0200A0E1 		mov	r0, r2
 3251 04e0 0310A0E1 		mov	r1, r3
 3252 04e4 FEFFFFEB 		bl	celda_poner_valor
 165:../timer.c    **** 					cuadricula_candidatos_verificar(cuadricula, selected_row, selected_column);
 3253              		.loc 1 165 0
 3254 04e8 7C329FE5 		ldr	r3, .L51+36
 3255 04ec 002093E5 		ldr	r2, [r3, #0]
 3256 04f0 78329FE5 		ldr	r3, .L51+40
 3257 04f4 003093E5 		ldr	r3, [r3, #0]
 3258 04f8 60029FE5 		ldr	r0, .L51+24
 3259 04fc 0210A0E1 		mov	r1, r2
 3260 0500 0320A0E1 		mov	r2, r3
 3261 0504 FEFFFFEB 		bl	cuadricula_candidatos_verificar
 166:../timer.c    **** 
 167:../timer.c    **** 					if (cuadricula[selected_row][selected_column] & 0x4000) // Comprobar si hay errores
 3262              		.loc 1 167 0
 3263 0508 5C329FE5 		ldr	r3, .L51+36
 3264 050c 001093E5 		ldr	r1, [r3, #0]
 3265 0510 58329FE5 		ldr	r3, .L51+40
 3266 0514 003093E5 		ldr	r3, [r3, #0]
 3267 0518 40229FE5 		ldr	r2, .L51+24
 3268 051c 0112A0E1 		mov	r1, r1, asl #4
 3269 0520 033081E0 		add	r3, r1, r3
 3270 0524 8330A0E1 		mov	r3, r3, asl #1
 3271 0528 033082E0 		add	r3, r2, r3
 3272 052c B030D3E1 		ldrh	r3, [r3, #0]
 3273 0530 013903E2 		and	r3, r3, #16384
 3274 0534 000053E3 		cmp	r3, #0
 3275 0538 0300000A 		beq	.L35
 168:../timer.c    **** 					{
 169:../timer.c    **** 						led8_count = 14; // Indicar error con una E en el 8led
 3276              		.loc 1 169 0
 3277 053c 20329FE5 		ldr	r3, .L51+28
 3278 0540 0E20A0E3 		mov	r2, #14
 3279 0544 002083E5 		str	r2, [r3, #0]
 170:../timer.c    **** 					}
 171:../timer.c    **** 					else // Si no hay errores, propagar el valor de la celda
 172:../timer.c    **** 					{
 173:../timer.c    **** 						sudoku_candidatos_propagar_c(cuadricula, selected_row, selected_column, led8_count);
 174:../timer.c    **** 
 175:../timer.c    **** 						led8_count = 15;
 176:../timer.c    **** 						sudoku_status = ROW_SELECTION;
 177:../timer.c    **** 					}
 178:../timer.c    **** 				}
 179:../timer.c    **** 
 180:../timer.c    **** 				break;
 3280              		.loc 1 180 0
 3281 0548 160000EA 		b	.L27
 3282              	.L35:
 173:../timer.c    **** 						sudoku_candidatos_propagar_c(cuadricula, selected_row, selected_column, led8_count);
 3283              		.loc 1 173 0
 3284 054c 18329FE5 		ldr	r3, .L51+36
 3285 0550 001093E5 		ldr	r1, [r3, #0]
 3286 0554 14329FE5 		ldr	r3, .L51+40
 3287 0558 002093E5 		ldr	r2, [r3, #0]
 3288 055c 00329FE5 		ldr	r3, .L51+28
 3289 0560 003093E5 		ldr	r3, [r3, #0]
 3290 0564 FF3003E2 		and	r3, r3, #255
 3291 0568 F0019FE5 		ldr	r0, .L51+24
 3292 056c FEFFFFEB 		bl	sudoku_candidatos_propagar_c
 175:../timer.c    **** 						led8_count = 15;
 3293              		.loc 1 175 0
 3294 0570 EC319FE5 		ldr	r3, .L51+28
 3295 0574 0F20A0E3 		mov	r2, #15
 3296 0578 002083E5 		str	r2, [r3, #0]
 176:../timer.c    **** 						sudoku_status = ROW_SELECTION;
 3297              		.loc 1 176 0
 3298 057c D8319FE5 		ldr	r3, .L51+20
 3299 0580 0220A0E3 		mov	r2, #2
 3300 0584 0020C3E5 		strb	r2, [r3, #0]
 3301              		.loc 1 180 0
 3302 0588 060000EA 		b	.L27
 3303              	.L43:
 181:../timer.c    **** 			default:
 182:../timer.c    **** 				break;
 3304              		.loc 1 182 0
 3305 058c 0000A0E1 		mov	r0, r0	@ nop
 3306 0590 040000EA 		b	.L27
 3307              	.L44:
 124:../timer.c    **** 				break;
 3308              		.loc 1 124 0
 3309 0594 0000A0E1 		mov	r0, r0	@ nop
 3310 0598 020000EA 		b	.L27
 3311              	.L45:
 151:../timer.c    **** 				break;
 3312              		.loc 1 151 0
 3313 059c 0000A0E1 		mov	r0, r0	@ nop
 3314 05a0 000000EA 		b	.L27
 3315              	.L46:
 180:../timer.c    **** 				break;
 3316              		.loc 1 180 0
 3317 05a4 0000A0E1 		mov	r0, r0	@ nop
 3318              	.L27:
 183:../timer.c    **** 			}
 184:../timer.c    **** 
 185:../timer.c    **** 			D8Led_symbol(led8_count & 0xf);
 3319              		.loc 1 185 0
 3320 05a8 B4319FE5 		ldr	r3, .L51+28
 3321 05ac 003093E5 		ldr	r3, [r3, #0]
 3322 05b0 0F3003E2 		and	r3, r3, #15
 3323 05b4 0300A0E1 		mov	r0, r3
 3324 05b8 FEFFFFEB 		bl	D8Led_symbol
 186:../timer.c    **** 
 187:../timer.c    **** 			if (!(rPDATG & 0x40) || !(rPDATG & 0x80))
 3325              		.loc 1 187 0
 3326 05bc A4319FE5 		ldr	r3, .L51+32
 3327 05c0 003093E5 		ldr	r3, [r3, #0]
 3328 05c4 403003E2 		and	r3, r3, #64
 3329 05c8 000053E3 		cmp	r3, #0
 3330 05cc 0400000A 		beq	.L36
 3331              		.loc 1 187 0 is_stmt 0 discriminator 1
 3332 05d0 90319FE5 		ldr	r3, .L51+32
 3333 05d4 003093E5 		ldr	r3, [r3, #0]
 3334 05d8 803003E2 		and	r3, r3, #128
 3335 05dc 000053E3 		cmp	r3, #0
 3336 05e0 0300001A 		bne	.L37
 3337              	.L36:
 188:../timer.c    **** 			{
 189:../timer.c    **** 				button_state = MANTAINED; // Cambiar a estado mantenido
 3338              		.loc 1 189 0 is_stmt 1
 3339 05e4 60319FE5 		ldr	r3, .L51+4
 3340 05e8 0320A0E3 		mov	r2, #3
 3341 05ec 0020C3E5 		strb	r2, [r3, #0]
 3342 05f0 020000EA 		b	.L38
 3343              	.L37:
 190:../timer.c    **** 			}
 191:../timer.c    **** 			else
 192:../timer.c    **** 			{
 193:../timer.c    **** 				button_state = RELEASED; // Cambiar a estado liberado
 3344              		.loc 1 193 0
 3345 05f4 50319FE5 		ldr	r3, .L51+4
 3346 05f8 0220A0E3 		mov	r2, #2
 3347 05fc 0020C3E5 		strb	r2, [r3, #0]
 3348              	.L38:
 194:../timer.c    **** 			}
 195:../timer.c    **** 			last_timer_value = timer1_leer(); // Actualizar tiempo
 3349              		.loc 1 195 0
 3350 0600 FEFFFFEB 		bl	timer1_leer
 3351 0604 0020A0E1 		mov	r2, r0
 3352 0608 44319FE5 		ldr	r3, .L51+12
 3353 060c 002083E5 		str	r2, [r3, #0]
 3354              	.LBE2:
 196:../timer.c    **** 		}
 197:../timer.c    **** 		break;
 3355              		.loc 1 197 0
 3356 0610 430000EA 		b	.L18
 3357              	.L15:
 198:../timer.c    **** 
 199:../timer.c    **** 	case MANTAINED:
 200:../timer.c    **** 		if ((timer1_leer() - last_timer_value) > 50000) // 50 ms
 3358              		.loc 1 200 0
 3359 0614 FEFFFFEB 		bl	timer1_leer
 3360 0618 0020A0E1 		mov	r2, r0
 3361 061c 30319FE5 		ldr	r3, .L51+12
 3362 0620 003093E5 		ldr	r3, [r3, #0]
 3363 0624 022063E0 		rsb	r2, r3, r2
 3364 0628 44319FE5 		ldr	r3, .L51+44
 3365 062c 030052E1 		cmp	r2, r3
 3366 0630 3400009A 		bls	.L47
 201:../timer.c    **** 		{
 202:../timer.c    **** 			if ((rPDATG & 0x40) && (rPDATG & 0x80)) // Botón liberado
 3367              		.loc 1 202 0
 3368 0634 2C319FE5 		ldr	r3, .L51+32
 3369 0638 003093E5 		ldr	r3, [r3, #0]
 3370 063c 403003E2 		and	r3, r3, #64
 3371 0640 000053E3 		cmp	r3, #0
 3372 0644 3100000A 		beq	.L48
 3373              		.loc 1 202 0 is_stmt 0 discriminator 1
 3374 0648 18319FE5 		ldr	r3, .L51+32
 3375 064c 003093E5 		ldr	r3, [r3, #0]
 3376 0650 803003E2 		and	r3, r3, #128
 3377 0654 000053E3 		cmp	r3, #0
 3378 0658 2E00000A 		beq	.L49
 203:../timer.c    **** 			{
 204:../timer.c    **** 				last_timer_value = timer1_leer();
 3379              		.loc 1 204 0 is_stmt 1
 3380 065c FEFFFFEB 		bl	timer1_leer
 3381 0660 0020A0E1 		mov	r2, r0
 3382 0664 E8309FE5 		ldr	r3, .L51+12
 3383 0668 002083E5 		str	r2, [r3, #0]
 205:../timer.c    **** 				button_state = RELEASED;
 3384              		.loc 1 205 0
 3385 066c D8309FE5 		ldr	r3, .L51+4
 3386 0670 0220A0E3 		mov	r2, #2
 3387 0674 0020C3E5 		strb	r2, [r3, #0]
 206:../timer.c    **** 			}
 207:../timer.c    **** 		}
 208:../timer.c    **** 		break;
 3388              		.loc 1 208 0
 3389 0678 290000EA 		b	.L18
 3390              	.L14:
 209:../timer.c    **** 
 210:../timer.c    **** 	case RELEASED:
 211:../timer.c    **** 		if ((timer1_leer() - last_timer_value) > 2752512) // TRD
 3391              		.loc 1 211 0
 3392 067c FEFFFFEB 		bl	timer1_leer
 3393 0680 0020A0E1 		mov	r2, r0
 3394 0684 C8309FE5 		ldr	r3, .L51+12
 3395 0688 003093E5 		ldr	r3, [r3, #0]
 3396 068c 023063E0 		rsb	r3, r3, r2
 3397 0690 2A0853E3 		cmp	r3, #2752512
 3398 0694 2100009A 		bls	.L50
 3399              	.LBB3:
 212:../timer.c    **** 		{
 213:../timer.c    **** 			push_debug(RELEASED_IRQ, button_id, timer1_leer());
 3400              		.loc 1 213 0
 3401 0698 D8309FE5 		ldr	r3, .L51+48
 3402 069c 004093E5 		ldr	r4, [r3, #0]
 3403 06a0 FEFFFFEB 		bl	timer1_leer
 3404 06a4 0030A0E1 		mov	r3, r0
 3405 06a8 0200A0E3 		mov	r0, #2
 3406 06ac 0410A0E1 		mov	r1, r4
 3407 06b0 0320A0E1 		mov	r2, r3
 3408 06b4 FEFFFFEB 		bl	push_debug
 214:../timer.c    **** 			button_state = WAITING;
 3409              		.loc 1 214 0
 3410 06b8 8C309FE5 		ldr	r3, .L51+4
 3411 06bc 0020A0E3 		mov	r2, #0
 3412 06c0 0020C3E5 		strb	r2, [r3, #0]
 215:../timer.c    **** 			rEXTINTPND = 0xF;						// Limpiar bits en EXTINTPND
 3413              		.loc 1 215 0
 3414 06c4 B0309FE5 		ldr	r3, .L51+52
 3415 06c8 0F20A0E3 		mov	r2, #15
 3416 06cc 002083E5 		str	r2, [r3, #0]
 216:../timer.c    **** 			rINTMSK &= ~(BIT_EINT4567); // Volver a habilitar las interrupciones de botones
 3417              		.loc 1 216 0
 3418 06d0 A8309FE5 		ldr	r3, .L51+56
 3419 06d4 A4209FE5 		ldr	r2, .L51+56
 3420 06d8 002092E5 		ldr	r2, [r2, #0]
 3421 06dc 0226C2E3 		bic	r2, r2, #2097152
 3422 06e0 002083E5 		str	r2, [r3, #0]
 3423              	.LBE3:
 217:../timer.c    **** 		}
 218:../timer.c    **** 		break;
 3424              		.loc 1 218 0
 3425 06e4 0E0000EA 		b	.L18
 3426              	.L11:
 219:../timer.c    **** 
 220:../timer.c    **** 	default:
 221:../timer.c    **** 		button_state = WAITING; // Reiniciar en caso de error
 3427              		.loc 1 221 0
 3428 06e8 5C309FE5 		ldr	r3, .L51+4
 3429 06ec 0020A0E3 		mov	r2, #0
 3430 06f0 0020C3E5 		strb	r2, [r3, #0]
 222:../timer.c    **** 		break;
 3431              		.loc 1 222 0
 3432 06f4 0A0000EA 		b	.L18
 3433              	.L41:
  92:../timer.c    **** 		break;
 3434              		.loc 1 92 0
 3435 06f8 0000A0E1 		mov	r0, r0	@ nop
 3436 06fc 080000EA 		b	.L18
 3437              	.L42:
 197:../timer.c    **** 		break;
 3438              		.loc 1 197 0
 3439 0700 0000A0E1 		mov	r0, r0	@ nop
 3440 0704 060000EA 		b	.L18
 3441              	.L47:
 208:../timer.c    **** 		break;
 3442              		.loc 1 208 0
 3443 0708 0000A0E1 		mov	r0, r0	@ nop
 3444 070c 040000EA 		b	.L18
 3445              	.L48:
 3446 0710 0000A0E1 		mov	r0, r0	@ nop
 3447 0714 020000EA 		b	.L18
 3448              	.L49:
 3449 0718 0000A0E1 		mov	r0, r0	@ nop
 3450 071c 000000EA 		b	.L18
 3451              	.L50:
 218:../timer.c    **** 		break;
 3452              		.loc 1 218 0
 3453 0720 0000A0E1 		mov	r0, r0	@ nop
 3454              	.L18:
 223:../timer.c    **** 	}
 224:../timer.c    **** 
 225:../timer.c    **** 	rI_ISPC |= BIT_TIMER1; // Limpiar interrupción
 3455              		.loc 1 225 0
 3456 0724 58309FE5 		ldr	r3, .L51+60
 3457 0728 54209FE5 		ldr	r2, .L51+60
 3458 072c 002092E5 		ldr	r2, [r2, #0]
 3459 0730 012A82E3 		orr	r2, r2, #4096
 3460 0734 002083E5 		str	r2, [r3, #0]
 226:../timer.c    **** }
 3461              		.loc 1 226 0
 3462 0738 24D04BE2 		sub	sp, fp, #36
 3463 073c 3F689DE8 		ldmfd	sp, {r0, r1, r2, r3, r4, r5, fp, sp, lr}
 3464 0740 04C09DE4 		ldmfd	sp!, {ip}
 3465 0744 04F05EE2 		subs	pc, lr, #4
 3466              	.L52:
 3467              		.align	2
 3468              	.L51:
 3469 0748 00000000 		.word	timer1_num_int
 3470 074c 00000000 		.word	button_state
 3471 0750 00000000 		.word	button_flag
 3472 0754 00000000 		.word	last_timer_value
 3473 0758 90260400 		.word	272016
 3474 075c 00000000 		.word	sudoku_status
 3475 0760 00000000 		.word	cuadricula
 3476 0764 00000000 		.word	led8_count
 3477 0768 4400D201 		.word	30539844
 3478 076c 08000000 		.word	selected_row
 3479 0770 0C000000 		.word	selected_column
 3480 0774 50C30000 		.word	50000
 3481 0778 00000000 		.word	button_id
 3482 077c 5400D201 		.word	30539860
 3483 0780 0C00E001 		.word	31457292
 3484 0784 2400E001 		.word	31457316
 3485              		.cfi_endproc
 3486              	.LFE3:
 3488              		.align	2
 3489              		.global	timer1_empezar
 3491              	timer1_empezar:
 3492              	.LFB4:
 227:../timer.c    **** 
 228:../timer.c    **** void timer1_empezar()
 229:../timer.c    **** {
 3493              		.loc 1 229 0
 3494              		.cfi_startproc
 3495              		@ Function supports interworking.
 3496              		@ args = 0, pretend = 0, frame = 0
 3497              		@ frame_needed = 1, uses_anonymous_args = 0
 3498 0788 0DC0A0E1 		mov	ip, sp
 3499              	.LCFI8:
 3500              		.cfi_def_cfa_register 12
 3501 078c 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3502 0790 04B04CE2 		sub	fp, ip, #4
 3503              		.cfi_offset 14, -8
 3504              		.cfi_offset 13, -12
 3505              		.cfi_offset 11, -16
 3506              	.LCFI9:
 3507              		.cfi_def_cfa 11, 4
 230:../timer.c    **** 	// Reiniciar el contador de interrupciones
 231:../timer.c    **** 	timer1_num_int = 0;
 3508              		.loc 1 231 0
 3509 0794 58309FE5 		ldr	r3, .L54
 3510 0798 0020A0E3 		mov	r2, #0
 3511 079c 002083E5 		str	r2, [r3, #0]
 232:../timer.c    **** 
 233:../timer.c    **** 	// Reiniciar el valor del contador del timer1
 234:../timer.c    **** 	rTCNTB1 = 64000;
 3512              		.loc 1 234 0
 3513 07a0 50309FE5 		ldr	r3, .L54+4
 3514 07a4 FA2CA0E3 		mov	r2, #64000
 3515 07a8 002083E5 		str	r2, [r3, #0]
 235:../timer.c    **** 
 236:../timer.c    **** 	// Establecer update=manual (bit 9) para reiniciar el contador
 237:../timer.c    **** 	rTCON |= (0x1 << 9);
 3516              		.loc 1 237 0
 3517 07ac 48309FE5 		ldr	r3, .L54+8
 3518 07b0 44209FE5 		ldr	r2, .L54+8
 3519 07b4 002092E5 		ldr	r2, [r2, #0]
 3520 07b8 022C82E3 		orr	r2, r2, #512
 3521 07bc 002083E5 		str	r2, [r3, #0]
 238:../timer.c    **** 
 239:../timer.c    **** 	// Iniciar el timer1 (bit 8)
 240:../timer.c    **** 	rTCON |= (0x1 << 8);
 3522              		.loc 1 240 0
 3523 07c0 34309FE5 		ldr	r3, .L54+8
 3524 07c4 30209FE5 		ldr	r2, .L54+8
 3525 07c8 002092E5 		ldr	r2, [r2, #0]
 3526 07cc 012C82E3 		orr	r2, r2, #256
 3527 07d0 002083E5 		str	r2, [r3, #0]
 241:../timer.c    **** 
 242:../timer.c    **** 	// Desactivar el bit de update manual para permitir el funcionamiento normal
 243:../timer.c    **** 	rTCON &= ~0x100;
 3528              		.loc 1 243 0
 3529 07d4 20309FE5 		ldr	r3, .L54+8
 3530 07d8 1C209FE5 		ldr	r2, .L54+8
 3531 07dc 002092E5 		ldr	r2, [r2, #0]
 3532 07e0 012CC2E3 		bic	r2, r2, #256
 3533 07e4 002083E5 		str	r2, [r3, #0]
 244:../timer.c    **** }
 3534              		.loc 1 244 0
 3535 07e8 0CD04BE2 		sub	sp, fp, #12
 3536 07ec 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3537 07f0 1EFF2FE1 		bx	lr
 3538              	.L55:
 3539              		.align	2
 3540              	.L54:
 3541 07f4 00000000 		.word	timer1_num_int
 3542 07f8 1800D501 		.word	30736408
 3543 07fc 0800D501 		.word	30736392
 3544              		.cfi_endproc
 3545              	.LFE4:
 3547              		.align	2
 3548              		.global	timer1_leer
 3550              	timer1_leer:
 3551              	.LFB5:
 245:../timer.c    **** 
 246:../timer.c    **** unsigned int timer1_leer()
 247:../timer.c    **** {
 3552              		.loc 1 247 0
 3553              		.cfi_startproc
 3554              		@ Function supports interworking.
 3555              		@ args = 0, pretend = 0, frame = 8
 3556              		@ frame_needed = 1, uses_anonymous_args = 0
 3557 0800 0DC0A0E1 		mov	ip, sp
 3558              	.LCFI10:
 3559              		.cfi_def_cfa_register 12
 3560 0804 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3561 0808 04B04CE2 		sub	fp, ip, #4
 3562              		.cfi_offset 14, -8
 3563              		.cfi_offset 13, -12
 3564              		.cfi_offset 11, -16
 3565              	.LCFI11:
 3566              		.cfi_def_cfa 11, 4
 3567 080c 08D04DE2 		sub	sp, sp, #8
 248:../timer.c    **** 
 249:../timer.c    **** 	unsigned int valor_cuenta = rTCNTO1; // Leer el valor actual del contador
 3568              		.loc 1 249 0
 3569 0810 3C309FE5 		ldr	r3, .L57
 3570 0814 003093E5 		ldr	r3, [r3, #0]
 3571 0818 10300BE5 		str	r3, [fp, #-16]
 250:../timer.c    **** 	// Calcular el tiempo transcurrido en el timer1
 251:../timer.c    **** 	// timer1_num_int * 64000 es el total de ticks de los ciclos completos
 252:../timer.c    **** 	// (2.0 / 33.0) es el factor de conversion de ticks a microsegundos
 253:../timer.c    **** 	unsigned int tiempo_transcurrido = (timer1_num_int * 65536) + (65535 - valor_cuenta);
 3572              		.loc 1 253 0
 3573 081c 34309FE5 		ldr	r3, .L57+4
 3574 0820 003093E5 		ldr	r3, [r3, #0]
 3575 0824 0338A0E1 		mov	r3, r3, asl #16
 3576 0828 0320A0E1 		mov	r2, r3
 3577 082c 10301BE5 		ldr	r3, [fp, #-16]
 3578 0830 023063E0 		rsb	r3, r3, r2
 3579 0834 FF3C83E2 		add	r3, r3, #65280
 3580 0838 FF3083E2 		add	r3, r3, #255
 3581 083c 14300BE5 		str	r3, [fp, #-20]
 254:../timer.c    **** 
 255:../timer.c    **** 	return tiempo_transcurrido;
 3582              		.loc 1 255 0
 3583 0840 14301BE5 		ldr	r3, [fp, #-20]
 256:../timer.c    **** }
 3584              		.loc 1 256 0
 3585 0844 0300A0E1 		mov	r0, r3
 3586 0848 0CD04BE2 		sub	sp, fp, #12
 3587 084c 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3588 0850 1EFF2FE1 		bx	lr
 3589              	.L58:
 3590              		.align	2
 3591              	.L57:
 3592 0854 2000D501 		.word	30736416
 3593 0858 00000000 		.word	timer1_num_int
 3594              		.cfi_endproc
 3595              	.LFE5:
 3597              		.align	2
 3598              		.global	timer1_parar
 3600              	timer1_parar:
 3601              	.LFB6:
 257:../timer.c    **** 
 258:../timer.c    **** unsigned int timer1_parar()
 259:../timer.c    **** {
 3602              		.loc 1 259 0
 3603              		.cfi_startproc
 3604              		@ Function supports interworking.
 3605              		@ args = 0, pretend = 0, frame = 0
 3606              		@ frame_needed = 1, uses_anonymous_args = 0
 3607 085c 0DC0A0E1 		mov	ip, sp
 3608              	.LCFI12:
 3609              		.cfi_def_cfa_register 12
 3610 0860 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3611 0864 04B04CE2 		sub	fp, ip, #4
 3612              		.cfi_offset 14, -8
 3613              		.cfi_offset 13, -12
 3614              		.cfi_offset 11, -16
 3615              	.LCFI13:
 3616              		.cfi_def_cfa 11, 4
 260:../timer.c    **** 	rTCON &= ~(0x1 << 8); // Desactivar el timer 1 (bit 9 y 11)
 3617              		.loc 1 260 0
 3618 0868 24309FE5 		ldr	r3, .L60
 3619 086c 20209FE5 		ldr	r2, .L60
 3620 0870 002092E5 		ldr	r2, [r2, #0]
 3621 0874 012CC2E3 		bic	r2, r2, #256
 3622 0878 002083E5 		str	r2, [r3, #0]
 261:../timer.c    **** 
 262:../timer.c    **** 	return timer1_leer();
 3623              		.loc 1 262 0
 3624 087c FEFFFFEB 		bl	timer1_leer
 3625 0880 0030A0E1 		mov	r3, r0
 263:../timer.c    **** }
 3626              		.loc 1 263 0
 3627 0884 0300A0E1 		mov	r0, r3
 3628 0888 0CD04BE2 		sub	sp, fp, #12
 3629 088c 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3630 0890 1EFF2FE1 		bx	lr
 3631              	.L61:
 3632              		.align	2
 3633              	.L60:
 3634 0894 0800D501 		.word	30736392
 3635              		.cfi_endproc
 3636              	.LFE6:
 3638              		.align	2
 3639              		.global	timer2_ISR
 3641              	timer2_ISR:
 3642              	.LFB7:
 264:../timer.c    **** 
 265:../timer.c    **** void timer2_ISR(void)
 266:../timer.c    **** {
 3643              		.loc 1 266 0
 3644              		.cfi_startproc
 3645              		@ Interrupt Service Routine.
 3646              		@ args = 0, pretend = 0, frame = 0
 3647              		@ frame_needed = 1, uses_anonymous_args = 0
 3648 0898 04C02DE5 		str	ip, [sp, #-4]!
 3649 089c 0DC0A0E1 		mov	ip, sp
 3650              	.LCFI14:
 3651              		.cfi_def_cfa_register 12
 3652 08a0 0FD82DE9 		stmfd	sp!, {r0, r1, r2, r3, fp, ip, lr, pc}
 3653 08a4 04B04CE2 		sub	fp, ip, #4
 3654              		.cfi_offset 14, -8
 3655              		.cfi_offset 13, -12
 3656              		.cfi_offset 11, -16
 3657              		.cfi_offset 3, -20
 3658              		.cfi_offset 2, -24
 3659              		.cfi_offset 1, -28
 3660              		.cfi_offset 0, -32
 3661              	.LCFI15:
 3662              		.cfi_def_cfa 11, 4
 267:../timer.c    **** 	led_event_counter++;
 3663              		.loc 1 267 0
 3664 08a8 70309FE5 		ldr	r3, .L66
 3665 08ac 003093E5 		ldr	r3, [r3, #0]
 3666 08b0 012083E2 		add	r2, r3, #1
 3667 08b4 64309FE5 		ldr	r3, .L66
 3668 08b8 002083E5 		str	r2, [r3, #0]
 268:../timer.c    **** 
 269:../timer.c    **** 	if (led_event_counter < 200)
 3669              		.loc 1 269 0
 3670 08bc 5C309FE5 		ldr	r3, .L66
 3671 08c0 003093E5 		ldr	r3, [r3, #0]
 3672 08c4 C70053E3 		cmp	r3, #199
 3673 08c8 010000CA 		bgt	.L63
 3674              	.LBB4:
 270:../timer.c    **** 	{
 271:../timer.c    **** 		led2_on();
 3675              		.loc 1 271 0
 3676 08cc FEFFFFEB 		bl	led2_on
 3677 08d0 090000EA 		b	.L64
 3678              	.L63:
 3679              	.LBE4:
 272:../timer.c    **** 	}
 273:../timer.c    **** 	else if (led_event_counter < 400)
 3680              		.loc 1 273 0
 3681 08d4 44309FE5 		ldr	r3, .L66
 3682 08d8 002093E5 		ldr	r2, [r3, #0]
 3683 08dc 40309FE5 		ldr	r3, .L66+4
 3684 08e0 030052E1 		cmp	r2, r3
 3685 08e4 010000CA 		bgt	.L65
 3686              	.LBB5:
 274:../timer.c    **** 	{
 275:../timer.c    **** 		led2_off();
 3687              		.loc 1 275 0
 3688 08e8 FEFFFFEB 		bl	led2_off
 3689 08ec 020000EA 		b	.L64
 3690              	.L65:
 3691              	.LBE5:
 276:../timer.c    **** 	}
 277:../timer.c    **** 	else
 278:../timer.c    **** 	{
 279:../timer.c    **** 		led_event_counter = 0; // Reiniciar el contador después de 160 eventos (2 segundos)
 3692              		.loc 1 279 0
 3693 08f0 28309FE5 		ldr	r3, .L66
 3694 08f4 0020A0E3 		mov	r2, #0
 3695 08f8 002083E5 		str	r2, [r3, #0]
 3696              	.L64:
 280:../timer.c    **** 	}
 281:../timer.c    **** 
 282:../timer.c    **** 	rI_ISPC |= BIT_TIMER2; // Limpiar la interrupción
 3697              		.loc 1 282 0
 3698 08fc 24309FE5 		ldr	r3, .L66+8
 3699 0900 20209FE5 		ldr	r2, .L66+8
 3700 0904 002092E5 		ldr	r2, [r2, #0]
 3701 0908 022B82E3 		orr	r2, r2, #2048
 3702 090c 002083E5 		str	r2, [r3, #0]
 283:../timer.c    **** }
 3703              		.loc 1 283 0
 3704 0910 1CD04BE2 		sub	sp, fp, #28
 3705 0914 0F689DE8 		ldmfd	sp, {r0, r1, r2, r3, fp, sp, lr}
 3706 0918 04C09DE4 		ldmfd	sp!, {ip}
 3707 091c 04F05EE2 		subs	pc, lr, #4
 3708              	.L67:
 3709              		.align	2
 3710              	.L66:
 3711 0920 00000000 		.word	led_event_counter
 3712 0924 8F010000 		.word	399
 3713 0928 2400E001 		.word	31457316
 3714              		.cfi_endproc
 3715              	.LFE7:
 3717              		.align	2
 3718              		.global	timer2_init
 3720              	timer2_init:
 3721              	.LFB8:
 284:../timer.c    **** 
 285:../timer.c    **** void timer2_init(void)
 286:../timer.c    **** {
 3722              		.loc 1 286 0
 3723              		.cfi_startproc
 3724              		@ Function supports interworking.
 3725              		@ args = 0, pretend = 0, frame = 0
 3726              		@ frame_needed = 1, uses_anonymous_args = 0
 3727 092c 0DC0A0E1 		mov	ip, sp
 3728              	.LCFI16:
 3729              		.cfi_def_cfa_register 12
 3730 0930 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3731 0934 04B04CE2 		sub	fp, ip, #4
 3732              		.cfi_offset 14, -8
 3733              		.cfi_offset 13, -12
 3734              		.cfi_offset 11, -16
 3735              	.LCFI17:
 3736              		.cfi_def_cfa 11, 4
 287:../timer.c    **** 	rINTMOD = 0x0;
 3737              		.loc 1 287 0
 3738 0938 AC309FE5 		ldr	r3, .L69
 3739 093c 0020A0E3 		mov	r2, #0
 3740 0940 002083E5 		str	r2, [r3, #0]
 288:../timer.c    **** 	rINTCON = 0x1;
 3741              		.loc 1 288 0
 3742 0944 1E36A0E3 		mov	r3, #31457280
 3743 0948 0120A0E3 		mov	r2, #1
 3744 094c 002083E5 		str	r2, [r3, #0]
 289:../timer.c    **** 	rINTMSK &= ~(BIT_TIMER2);
 3745              		.loc 1 289 0
 3746 0950 98309FE5 		ldr	r3, .L69+4
 3747 0954 94209FE5 		ldr	r2, .L69+4
 3748 0958 002092E5 		ldr	r2, [r2, #0]
 3749 095c 022BC2E3 		bic	r2, r2, #2048
 3750 0960 002083E5 		str	r2, [r3, #0]
 290:../timer.c    **** 
 291:../timer.c    **** 	pISR_TIMER2 = (unsigned)timer2_ISR;
 3751              		.loc 1 291 0
 3752 0964 88309FE5 		ldr	r3, .L69+8
 3753 0968 88209FE5 		ldr	r2, .L69+12
 3754 096c 002083E5 		str	r2, [r3, #0]
 292:../timer.c    **** 
 293:../timer.c    **** 	rTCFG0 = 0x8;
 3755              		.loc 1 293 0
 3756 0970 84309FE5 		ldr	r3, .L69+16
 3757 0974 0820A0E3 		mov	r2, #8
 3758 0978 002083E5 		str	r2, [r3, #0]
 294:../timer.c    **** 	rTCFG1 = 0x0;
 3759              		.loc 1 294 0
 3760 097c 7C309FE5 		ldr	r3, .L69+20
 3761 0980 0020A0E3 		mov	r2, #0
 3762 0984 002083E5 		str	r2, [r3, #0]
 295:../timer.c    **** 
 296:../timer.c    **** 	rTCNTB2 = 100000;
 3763              		.loc 1 296 0
 3764 0988 74309FE5 		ldr	r3, .L69+24
 3765 098c 74209FE5 		ldr	r2, .L69+28
 3766 0990 002083E5 		str	r2, [r3, #0]
 297:../timer.c    **** 	rTCMPB2 = 0x0;
 3767              		.loc 1 297 0
 3768 0994 70309FE5 		ldr	r3, .L69+32
 3769 0998 0020A0E3 		mov	r2, #0
 3770 099c 002083E5 		str	r2, [r3, #0]
 298:../timer.c    **** 
 299:../timer.c    **** 	rTCON |= (1 << 13); // Actualización manual
 3771              		.loc 1 299 0
 3772 09a0 68309FE5 		ldr	r3, .L69+36
 3773 09a4 64209FE5 		ldr	r2, .L69+36
 3774 09a8 002092E5 		ldr	r2, [r2, #0]
 3775 09ac 022A82E3 		orr	r2, r2, #8192
 3776 09b0 002083E5 		str	r2, [r3, #0]
 300:../timer.c    **** 	rTCON &= ~(1 << 15);
 3777              		.loc 1 300 0
 3778 09b4 54309FE5 		ldr	r3, .L69+36
 3779 09b8 50209FE5 		ldr	r2, .L69+36
 3780 09bc 002092E5 		ldr	r2, [r2, #0]
 3781 09c0 0229C2E3 		bic	r2, r2, #32768
 3782 09c4 002083E5 		str	r2, [r3, #0]
 301:../timer.c    **** 
 302:../timer.c    **** 	rTCON = (rTCON & ~(0x1 << 13)) | (0x1 << 15) | (0x1 << 12); // Auto-reload y Start
 3783              		.loc 1 302 0
 3784 09c8 40309FE5 		ldr	r3, .L69+36
 3785 09cc 3C209FE5 		ldr	r2, .L69+36
 3786 09d0 002092E5 		ldr	r2, [r2, #0]
 3787 09d4 0B2AC2E3 		bic	r2, r2, #45056
 3788 09d8 092A82E3 		orr	r2, r2, #36864
 3789 09dc 002083E5 		str	r2, [r3, #0]
 303:../timer.c    **** }
 3790              		.loc 1 303 0
 3791 09e0 0CD04BE2 		sub	sp, fp, #12
 3792 09e4 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3793 09e8 1EFF2FE1 		bx	lr
 3794              	.L70:
 3795              		.align	2
 3796              	.L69:
 3797 09ec 0800E001 		.word	31457288
 3798 09f0 0C00E001 		.word	31457292
 3799 09f4 4CFF7F0C 		.word	209715020
 3800 09f8 00000000 		.word	timer2_ISR
 3801 09fc 0000D501 		.word	30736384
 3802 0a00 0400D501 		.word	30736388
 3803 0a04 2400D501 		.word	30736420
 3804 0a08 A0860100 		.word	100000
 3805 0a0c 2800D501 		.word	30736424
 3806 0a10 0800D501 		.word	30736392
 3807              		.cfi_endproc
 3808              	.LFE8:
 3810              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 timer.c
                            *COM*:00000004 switch_leds
C:\Users\Jorge\AppData\Local\Temp\cch6KfLv.s:2750   .bss:00000000 timer1_num_int
C:\Users\Jorge\AppData\Local\Temp\cch6KfLv.s:2747   .bss:00000000 $d
C:\Users\Jorge\AppData\Local\Temp\cch6KfLv.s:2756   .bss:00000004 led_event_counter
C:\Users\Jorge\AppData\Local\Temp\cch6KfLv.s:2759   .bss:00000008 selected_row
C:\Users\Jorge\AppData\Local\Temp\cch6KfLv.s:2762   .bss:0000000c selected_column
C:\Users\Jorge\AppData\Local\Temp\cch6KfLv.s:2765   .text:00000000 $a
C:\Users\Jorge\AppData\Local\Temp\cch6KfLv.s:2768   .text:00000000 timer_ISR
C:\Users\Jorge\AppData\Local\Temp\cch6KfLv.s:2806   .text:00000040 $d
C:\Users\Jorge\AppData\Local\Temp\cch6KfLv.s:2811   .text:00000048 $a
C:\Users\Jorge\AppData\Local\Temp\cch6KfLv.s:2814   .text:00000048 timer_init
C:\Users\Jorge\AppData\Local\Temp\cch6KfLv.s:2880   .text:000000e0 $d
C:\Users\Jorge\AppData\Local\Temp\cch6KfLv.s:2893   .text:00000108 $a
C:\Users\Jorge\AppData\Local\Temp\cch6KfLv.s:2896   .text:00000108 timer1_inicializar
C:\Users\Jorge\AppData\Local\Temp\cch6KfLv.s:2973   .text:000001c8 $d
C:\Users\Jorge\AppData\Local\Temp\cch6KfLv.s:2988   .text:000001ec timer1_ISR
C:\Users\Jorge\AppData\Local\Temp\cch6KfLv.s:2985   .text:000001ec $a
C:\Users\Jorge\AppData\Local\Temp\cch6KfLv.s:3026   .text:00000228 $d
C:\Users\Jorge\AppData\Local\Temp\cch6KfLv.s:3032   .text:00000238 $a
C:\Users\Jorge\AppData\Local\Temp\cch6KfLv.s:3550   .text:00000800 timer1_leer
C:\Users\Jorge\AppData\Local\Temp\cch6KfLv.s:3070   .text:000002ac $d
C:\Users\Jorge\AppData\Local\Temp\cch6KfLv.s:3077   .text:000002c0 $a
C:\Users\Jorge\AppData\Local\Temp\cch6KfLv.s:3469   .text:00000748 $d
C:\Users\Jorge\AppData\Local\Temp\cch6KfLv.s:3488   .text:00000788 $a
C:\Users\Jorge\AppData\Local\Temp\cch6KfLv.s:3491   .text:00000788 timer1_empezar
C:\Users\Jorge\AppData\Local\Temp\cch6KfLv.s:3541   .text:000007f4 $d
C:\Users\Jorge\AppData\Local\Temp\cch6KfLv.s:3547   .text:00000800 $a
C:\Users\Jorge\AppData\Local\Temp\cch6KfLv.s:3592   .text:00000854 $d
C:\Users\Jorge\AppData\Local\Temp\cch6KfLv.s:3597   .text:0000085c $a
C:\Users\Jorge\AppData\Local\Temp\cch6KfLv.s:3600   .text:0000085c timer1_parar
C:\Users\Jorge\AppData\Local\Temp\cch6KfLv.s:3634   .text:00000894 $d
C:\Users\Jorge\AppData\Local\Temp\cch6KfLv.s:3638   .text:00000898 $a
C:\Users\Jorge\AppData\Local\Temp\cch6KfLv.s:3641   .text:00000898 timer2_ISR
C:\Users\Jorge\AppData\Local\Temp\cch6KfLv.s:3711   .text:00000920 $d
C:\Users\Jorge\AppData\Local\Temp\cch6KfLv.s:3717   .text:0000092c $a
C:\Users\Jorge\AppData\Local\Temp\cch6KfLv.s:3720   .text:0000092c timer2_init
C:\Users\Jorge\AppData\Local\Temp\cch6KfLv.s:3797   .text:000009ec $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
sudoku_candidatos_init_c
celda_poner_valor
cuadricula_candidatos_verificar
sudoku_candidatos_propagar_c
D8Led_symbol
push_debug
button_state
button_flag
last_timer_value
sudoku_status
cuadricula
led8_count
button_id
led2_on
led2_off
